{"ast":null,"code":"import { debug } from './debug-logger.js';\nimport { baggageHeaderToDynamicSamplingContext } from './baggage.js';\nimport { extractOrgIdFromClient } from './dsn.js';\nimport { parseSampleRate } from './parseSampleRate.js';\nimport { generateTraceId, generateSpanId } from './propagationContext.js';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp('^[ \\\\t]*' +\n// whitespace\n'([0-9a-f]{32})?' +\n// trace_id\n'-?([0-9a-f]{16})?' +\n// span_id\n'-?([01])?' +\n// sampled\n'[ \\\\t]*$') // whitespace\n;\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  if (!traceparent) {\n    return undefined;\n  }\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2]\n  };\n}\n\n/**\n * Create a propagation context from incoming headers or\n * creates a minimal new one if the headers are undefined.\n */\nfunction propagationContextFromHeaders(sentryTrace, baggage) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n  if (!traceparentData?.traceId) {\n    return {\n      traceId: generateTraceId(),\n      sampleRand: Math.random()\n    };\n  }\n  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);\n\n  // The sample_rand on the DSC needs to be generated based on traceparent + baggage.\n  if (dynamicSamplingContext) {\n    dynamicSamplingContext.sample_rand = sampleRand.toString();\n  }\n  const {\n    traceId,\n    parentSpanId,\n    parentSampled\n  } = traceparentData;\n  return {\n    traceId,\n    parentSpanId,\n    sampled: parentSampled,\n    dsc: dynamicSamplingContext || {},\n    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    sampleRand\n  };\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nfunction generateSentryTraceHeader() {\n  let traceId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateTraceId();\n  let spanId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : generateSpanId();\n  let sampled = arguments.length > 2 ? arguments[2] : undefined;\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n\n/**\n * Given any combination of an incoming trace, generate a sample rand based on its defined semantics.\n *\n * Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n */\nfunction getSampleRandFromTraceparentAndDsc(traceparentData, dsc) {\n  // When there is an incoming sample rand use it.\n  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);\n  if (parsedSampleRand !== undefined) {\n    return parsedSampleRand;\n  }\n\n  // Otherwise, if there is an incoming sampling decision + sample rate, generate a sample rand that would lead to the same sampling decision.\n  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);\n  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {\n    return traceparentData.parentSampled ?\n    // Returns a sample rand with positive sampling decision [0, sampleRate)\n    Math.random() * parsedSampleRate :\n    // Returns a sample rand with negative sampling decision [sampleRate, 1)\n    parsedSampleRate + Math.random() * (1 - parsedSampleRate);\n  } else {\n    // If nothing applies, return a random sample rand.\n    return Math.random();\n  }\n}\n\n/**\n * Determines whether a new trace should be continued based on the provided baggage org ID and the client's `strictTraceContinuation` option.\n * If the trace should not be continued, a new trace will be started.\n *\n * The result is dependent on the `strictTraceContinuation` option in the client.\n * See https://develop.sentry.dev/sdk/telemetry/traces/#stricttracecontinuation\n */\nfunction shouldContinueTrace(client, baggageOrgId) {\n  const clientOrgId = extractOrgIdFromClient(client);\n\n  // Case: baggage orgID and Client orgID don't match - always start new trace\n  if (baggageOrgId && clientOrgId && baggageOrgId !== clientOrgId) {\n    debug.log(`Won't continue trace because org IDs don't match (incoming baggage: ${baggageOrgId}, SDK options: ${clientOrgId})`);\n    return false;\n  }\n  const strictTraceContinuation = client.getOptions().strictTraceContinuation || false; // default for `strictTraceContinuation` is `false`\n\n  if (strictTraceContinuation) {\n    // With strict continuation enabled, don't continue trace if:\n    // - Baggage has orgID, but Client doesn't have one\n    // - Client has orgID, but baggage doesn't have one\n    if (baggageOrgId && !clientOrgId || !baggageOrgId && clientOrgId) {\n      debug.log(`Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${baggageOrgId}, Sentry client: ${clientOrgId})`);\n      return false;\n    }\n  }\n  return true;\n}\nexport { TRACEPARENT_REGEXP, extractTraceparentData, generateSentryTraceHeader, propagationContextFromHeaders, shouldContinueTrace };","map":{"version":3,"names":["TRACEPARENT_REGEXP","RegExp","extractTraceparentData","traceparent","undefined","matches","match","parentSampled","traceId","parentSpanId","propagationContextFromHeaders","sentryTrace","baggage","traceparentData","dynamicSamplingContext","baggageHeaderToDynamicSamplingContext","generateTraceId","sampleRand","Math","random","getSampleRandFromTraceparentAndDsc","sample_rand","toString","sampled","dsc","generateSentryTraceHeader","arguments","length","spanId","generateSpanId","sampledString","parsedSampleRand","parseSampleRate","parsedSampleRate","sample_rate","shouldContinueTrace","client","baggageOrgId","clientOrgId","extractOrgIdFromClient","debug","log","strictTraceContinuation","getOptions"],"sources":["/workspace/node_modules/@sentry/core/src/utils/tracing.ts"],"sourcesContent":["import type { Client } from '../client';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport type { PropagationContext } from '../types-hoist/tracing';\nimport type { TraceparentData } from '../types-hoist/transaction';\nimport { debug } from '../utils/debug-logger';\nimport { baggageHeaderToDynamicSamplingContext } from './baggage';\nimport { extractOrgIdFromClient } from './dsn';\nimport { parseSampleRate } from './parseSampleRate';\nimport { generateSpanId, generateTraceId } from './propagationContext';\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nexport const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nexport function extractTraceparentData(traceparent?: string): TraceparentData | undefined {\n  if (!traceparent) {\n    return undefined;\n  }\n\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n\n  let parentSampled: boolean | undefined;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\n/**\n * Create a propagation context from incoming headers or\n * creates a minimal new one if the headers are undefined.\n */\nexport function propagationContextFromHeaders(\n  sentryTrace: string | undefined,\n  baggage: string | number | boolean | string[] | null | undefined,\n): PropagationContext {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n  if (!traceparentData?.traceId) {\n    return {\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);\n\n  // The sample_rand on the DSC needs to be generated based on traceparent + baggage.\n  if (dynamicSamplingContext) {\n    dynamicSamplingContext.sample_rand = sampleRand.toString();\n  }\n\n  const { traceId, parentSpanId, parentSampled } = traceparentData;\n\n  return {\n    traceId,\n    parentSpanId,\n    sampled: parentSampled,\n    dsc: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    sampleRand,\n  };\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nexport function generateSentryTraceHeader(\n  traceId: string | undefined = generateTraceId(),\n  spanId: string | undefined = generateSpanId(),\n  sampled?: boolean,\n): string {\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n\n/**\n * Given any combination of an incoming trace, generate a sample rand based on its defined semantics.\n *\n * Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n */\nfunction getSampleRandFromTraceparentAndDsc(\n  traceparentData: TraceparentData | undefined,\n  dsc: Partial<DynamicSamplingContext> | undefined,\n): number {\n  // When there is an incoming sample rand use it.\n  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);\n  if (parsedSampleRand !== undefined) {\n    return parsedSampleRand;\n  }\n\n  // Otherwise, if there is an incoming sampling decision + sample rate, generate a sample rand that would lead to the same sampling decision.\n  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);\n  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {\n    return traceparentData.parentSampled\n      ? // Returns a sample rand with positive sampling decision [0, sampleRate)\n        Math.random() * parsedSampleRate\n      : // Returns a sample rand with negative sampling decision [sampleRate, 1)\n        parsedSampleRate + Math.random() * (1 - parsedSampleRate);\n  } else {\n    // If nothing applies, return a random sample rand.\n    return Math.random();\n  }\n}\n\n/**\n * Determines whether a new trace should be continued based on the provided baggage org ID and the client's `strictTraceContinuation` option.\n * If the trace should not be continued, a new trace will be started.\n *\n * The result is dependent on the `strictTraceContinuation` option in the client.\n * See https://develop.sentry.dev/sdk/telemetry/traces/#stricttracecontinuation\n */\nexport function shouldContinueTrace(client: Client, baggageOrgId?: string): boolean {\n  const clientOrgId = extractOrgIdFromClient(client);\n\n  // Case: baggage orgID and Client orgID don't match - always start new trace\n  if (baggageOrgId && clientOrgId && baggageOrgId !== clientOrgId) {\n    debug.log(\n      `Won't continue trace because org IDs don't match (incoming baggage: ${baggageOrgId}, SDK options: ${clientOrgId})`,\n    );\n    return false;\n  }\n\n  const strictTraceContinuation = client.getOptions().strictTraceContinuation || false; // default for `strictTraceContinuation` is `false`\n\n  if (strictTraceContinuation) {\n    // With strict continuation enabled, don't continue trace if:\n    // - Baggage has orgID, but Client doesn't have one\n    // - Client has orgID, but baggage doesn't have one\n    if ((baggageOrgId && !clientOrgId) || (!baggageOrgId && clientOrgId)) {\n      debug.log(\n        `Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${baggageOrgId}, Sentry client: ${clientOrgId})`,\n      );\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}