{"ast":null,"code":"import { debug, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\nconst handlers = {};\nconst instrumented = {};\nlet _previousCls;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a TTFD metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(callback) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(type, callback) {\n  addHandler(type, callback);\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n  if (!typeHandlers?.length) {\n    return;\n  }\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD && debug.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\nfunction instrumentCls() {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric\n    });\n    _previousCls = metric;\n  },\n  // We want the callback to be called whenever the CLS value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentLcp() {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric\n    });\n    _previousLcp = metric;\n  },\n  // We want the callback to be called whenever the LCP value updates.\n  // By default, the callback is only called when the tab goes to the background.\n  {\n    reportAllChanges: true\n  });\n}\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric\n    });\n    _previousTtfb = metric;\n  });\n}\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric\n    });\n    _previousInp = metric;\n  });\n}\nfunction addMetricObserver(type, callback, instrumentFn, previousValue) {\n  let stopOnCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  addHandler(type, callback);\n  let stopListening;\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n  if (previousValue) {\n    callback({\n      metric: previousValue\n    });\n  }\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n  observe(type, entries => {\n    triggerHandlers(type, {\n      entries\n    });\n  }, options);\n}\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type, callback, stopListening) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n    const typeHandlers = handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nfunction isPerformanceEventTiming(entry) {\n  return 'duration' in entry;\n}\nexport { addClsInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler, isPerformanceEventTiming };","map":{"version":3,"names":["handlers","instrumented","_previousCls","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","callback","stopOnCallback","arguments","length","undefined","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addTtfbInstrumentationHandler","instrumentTtfb","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","type","addHandler","instrumentPerformanceObserver","getCleanupCallback","triggerHandlers","data","typeHandlers","handler","e","DEBUG_BUILD","debug","error","getFunctionName","onCLS","metric","reportAllChanges","onLCP","onTTFB","onINP","instrumentFn","previousValue","stopListening","options","durationThreshold","observe","entries","push","index","indexOf","splice","isPerformanceEventTiming","entry"],"sources":["/workspace/node_modules/@sentry-internal/browser-utils/src/metrics/instrument.ts"],"sourcesContent":["import { debug, getFunctionName } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { onCLS } from './web-vitals/getCLS';\nimport { onINP } from './web-vitals/getINP';\nimport { onLCP } from './web-vitals/getLCP';\nimport { observe } from './web-vitals/lib/observe';\nimport { onTTFB } from './web-vitals/onTTFB';\n\ntype InstrumentHandlerTypePerformanceObserver =\n  | 'longtask'\n  | 'event'\n  | 'navigation'\n  | 'paint'\n  | 'resource'\n  | 'element'\n  // fist-input is still needed for INP\n  | 'first-input';\n\ntype InstrumentHandlerTypeMetric = 'cls' | 'lcp' | 'ttfb' | 'inp';\n\n// We provide this here manually instead of relying on a global, as this is not available in non-browser environements\n// And we do not want to expose such types\ninterface PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): Record<string, unknown>;\n}\ninterface PerformanceEventTiming extends PerformanceEntry {\n  processingStart: number;\n  processingEnd: number;\n  duration: number;\n  cancelable?: boolean;\n  target?: unknown | null;\n  interactionId?: number;\n}\n\ninterface PerformanceScriptTiming extends PerformanceEntry {\n  sourceURL: string;\n  sourceFunctionName: string;\n  sourceCharPosition: number;\n  invoker: string;\n  invokerType: string;\n}\nexport interface PerformanceLongAnimationFrameTiming extends PerformanceEntry {\n  scripts: PerformanceScriptTiming[];\n}\n\ninterface Metric {\n  /**\n   * The name of the metric (in acronym form).\n   */\n  name: 'CLS' | 'FCP' | 'INP' | 'LCP' | 'TTFB';\n\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * The delta between the current value and the last-reported value.\n   * On the first report, `delta` and `value` will always be the same.\n   */\n  delta: number;\n\n  /**\n   * A unique ID representing this particular metric instance. This ID can\n   * be used by an analytics tool to dedupe multiple values sent for the same\n   * metric instance, or to group multiple deltas together and calculate a\n   * total. It can also be used to differentiate multiple different metric\n   * instances sent from the same page, which can happen if the page is\n   * restored from the back/forward cache (in that case new metrics object\n   * get created).\n   */\n  id: string;\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[];\n\n  /**\n   * The type of navigation\n   *\n   * Navigation Timing API (or `undefined` if the browser doesn't\n   * support that API). For pages that are restored from the bfcache, this\n   * value will be 'back-forward-cache'.\n   */\n  navigationType: 'navigate' | 'reload' | 'back-forward' | 'back-forward-cache' | 'prerender' | 'restore';\n}\n\ntype InstrumentHandlerType = InstrumentHandlerTypeMetric | InstrumentHandlerTypePerformanceObserver;\n\ntype StopListening = undefined | void | (() => void);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype InstrumentHandlerCallback = (data: any) => void;\n\ntype CleanupHandlerCallback = () => void;\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\nlet _previousCls: Metric | undefined;\nlet _previousLcp: Metric | undefined;\nlet _previousTtfb: Metric | undefined;\nlet _previousInp: Metric | undefined;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nexport function addClsInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nexport function addLcpInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a TTFD metric is available.\n */\nexport function addTtfbInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\nexport type InstrumentationHandlerCallback = (data: {\n  metric: Omit<Metric, 'entries'> & {\n    entries: PerformanceEventTiming[];\n  };\n}) => void;\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addInpInstrumentationHandler(callback: InstrumentationHandlerCallback): CleanupHandlerCallback {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\nexport function addPerformanceInstrumentationHandler(\n  type: 'event',\n  callback: (data: { entries: ((PerformanceEntry & { target?: unknown | null }) | PerformanceEventTiming)[] }) => void,\n): CleanupHandlerCallback;\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback;\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers?.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        debug.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls(): StopListening {\n  return onCLS(\n    metric => {\n      triggerHandlers('cls', {\n        metric,\n      });\n      _previousCls = metric;\n    },\n    // We want the callback to be called whenever the CLS value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentLcp(): StopListening {\n  return onLCP(\n    metric => {\n      triggerHandlers('lcp', {\n        metric,\n      });\n      _previousLcp = metric;\n    },\n    // We want the callback to be called whenever the LCP value updates.\n    // By default, the callback is only called when the tab goes to the background.\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentTtfb(): StopListening {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp(): void {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type: InstrumentHandlerTypeMetric,\n  callback: InstrumentHandlerCallback,\n  instrumentFn: () => StopListening,\n  previousValue: Metric | undefined,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  let stopListening: StopListening | undefined;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type: InstrumentHandlerTypePerformanceObserver): void {\n  const options: PerformanceObserverInit = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type: InstrumentHandlerType,\n  callback: InstrumentHandlerCallback,\n  stopListening: StopListening,\n): CleanupHandlerCallback {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n\n/**\n * Check if a PerformanceEntry is a PerformanceEventTiming by checking for the `duration` property.\n */\nexport function isPerformanceEventTiming(entry: PerformanceEntry): entry is PerformanceEventTiming {\n  return 'duration' in entry;\n}\n"],"mappings":";;;;;;;AA6GA,MAAMA,QAAQ,GAAqE,EAAE;AACrF,MAAMC,YAAY,GAAiD,EAAE;AAErE,IAAIC,YAAY;AAChB,IAAIC,YAAY;AAChB,IAAIC,aAAa;AACjB,IAAIC,YAAY;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,4BAA4BA,CAC1CC,QAAQ,EAEgB;EAAA,IADxBC,cAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,KAAK;EAEtB,OAAOG,iBAAiB,CAAC,KAAK,EAAEL,QAAQ,EAAEM,aAAa,EAAEX,YAAY,EAAEM,cAAc,CAAC;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASM,4BAA4BA,CAC1CP,QAAQ,EAEgB;EAAA,IADxBC,cAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,KAAK;EAEtB,OAAOG,iBAAiB,CAAC,KAAK,EAAEL,QAAQ,EAAEQ,aAAa,EAAEZ,YAAY,EAAEK,cAAc,CAAC;AACxF;;AAEA;AACA;AACA;AACO,SAASQ,6BAA6BA,CAACT,QAAQ,EAA8D;EAClH,OAAOK,iBAAiB,CAAC,MAAM,EAAEL,QAAQ,EAAEU,cAAc,EAAEb,aAAa,CAAC;AAC3E;;AAQA;AACA;AACA;AACA;AACO,SAASc,4BAA4BA,CAACX,QAAQ,EAA0D;EAC7G,OAAOK,iBAAiB,CAAC,KAAK,EAAEL,QAAQ,EAAEY,aAAa,EAAEd,YAAY,CAAC;AACxE;;AAWA;AACA;AACA;AACA;AACA;AACO,SAASe,oCAAoCA,CAClDC,IAAI,EACJd,QAAQ,EACgB;EACxBe,UAAU,CAACD,IAAI,EAAEd,QAAQ,CAAC;EAE1B,IAAI,CAACN,YAAY,CAACoB,IAAI,CAAC,EAAE;IACvBE,6BAA6B,CAACF,IAAI,CAAC;IACnCpB,YAAY,CAACoB,IAAI,IAAI,IAAI;EAC7B;EAEE,OAAOG,kBAAkB,CAACH,IAAI,EAAEd,QAAQ,CAAC;AAC3C;;AAEA;AACA,SAASkB,eAAeA,CAACJ,IAAI,EAAyBK,IAAI,EAAiB;EACzE,MAAMC,YAAA,GAAe3B,QAAQ,CAACqB,IAAI,CAAC;EAEnC,IAAI,CAACM,YAAY,EAAEjB,MAAM,EAAE;IACzB;EACJ;EAEE,KAAK,MAAMkB,OAAA,IAAWD,YAAY,EAAE;IAClC,IAAI;MACFC,OAAO,CAACF,IAAI,CAAC;IACnB,CAAI,CAAE,OAAOG,CAAC,EAAE;MACVC,WAAA,IACEC,KAAK,CAACC,KAAK,CACT,0DAA0DX,IAAI,WAAWY,eAAe,CAACL,OAAO,CAAC,UAAU,EAC3GC,CACV,CAAS;IACT;EACA;AACA;AAEA,SAAShB,aAAaA,CAAA,EAAkB;EACtC,OAAOqB,KAAK,CACVC,MAAA,IAAU;IACRV,eAAe,CAAC,KAAK,EAAE;MACrBU;IACR,CAAO,CAAC;IACFjC,YAAA,GAAeiC,MAAM;EAC3B,CAAK;EACL;EACA;EACI;IAAEC,gBAAgB,EAAE;EAAA,CACxB,CAAG;AACH;AAEA,SAASrB,aAAaA,CAAA,EAAkB;EACtC,OAAOsB,KAAK,CACVF,MAAA,IAAU;IACRV,eAAe,CAAC,KAAK,EAAE;MACrBU;IACR,CAAO,CAAC;IACFhC,YAAA,GAAegC,MAAM;EAC3B,CAAK;EACL;EACA;EACI;IAAEC,gBAAgB,EAAE;EAAA,CACxB,CAAG;AACH;AAEA,SAASnB,cAAcA,CAAA,EAAkB;EACvC,OAAOqB,MAAM,CAACH,MAAA,IAAU;IACtBV,eAAe,CAAC,MAAM,EAAE;MACtBU;IACN,CAAK,CAAC;IACF/B,aAAA,GAAgB+B,MAAM;EAC1B,CAAG,CAAC;AACJ;AAEA,SAAShB,aAAaA,CAAA,EAAS;EAC7B,OAAOoB,KAAK,CAACJ,MAAA,IAAU;IACrBV,eAAe,CAAC,KAAK,EAAE;MACrBU;IACN,CAAK,CAAC;IACF9B,YAAA,GAAe8B,MAAM;EACzB,CAAG,CAAC;AACJ;AAEA,SAASvB,iBAAiBA,CACxBS,IAAI,EACJd,QAAQ,EACRiC,YAAY,EACZC,aAAa,EAEW;EAAA,IADxBjC,cAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,KAAK;EAEtBa,UAAU,CAACD,IAAI,EAAEd,QAAQ,CAAC;EAE1B,IAAImC,aAAa;EAEjB,IAAI,CAACzC,YAAY,CAACoB,IAAI,CAAC,EAAE;IACvBqB,aAAA,GAAgBF,YAAY,EAAE;IAC9BvC,YAAY,CAACoB,IAAI,IAAI,IAAI;EAC7B;EAEE,IAAIoB,aAAa,EAAE;IACjBlC,QAAQ,CAAC;MAAE4B,MAAM,EAAEM;IAAA,CAAe,CAAC;EACvC;EAEE,OAAOjB,kBAAkB,CAACH,IAAI,EAAEd,QAAQ,EAAEC,cAAA,GAAiBkC,aAAA,GAAgB/B,SAAS,CAAC;AACvF;AAEA,SAASY,6BAA6BA,CAACF,IAAI,EAAkD;EAC3F,MAAMsB,OAAO,GAA4B,EAAE;;EAE7C;EACE,IAAItB,IAAA,KAAS,OAAO,EAAE;IACpBsB,OAAO,CAACC,iBAAA,GAAoB,CAAC;EACjC;EAEEC,OAAO,CACLxB,IAAI,EACJyB,OAAA,IAAW;IACTrB,eAAe,CAACJ,IAAI,EAAE;MAAEyB;IAAA,CAAS,CAAC;EACxC,CAAK,EACDH,OACJ,CAAG;AACH;AAEA,SAASrB,UAAUA,CAACD,IAAI,EAAyBO,OAAO,EAAmC;EACzF5B,QAAQ,CAACqB,IAAI,IAAIrB,QAAQ,CAACqB,IAAI,KAAK,EAAE;EACpCrB,QAAQ,CAACqB,IAAI,EAAkC0B,IAAI,CAACnB,OAAO,CAAC;AAC/D;;AAEA;AACA,SAASJ,kBAAkBA,CACzBH,IAAI,EACJd,QAAQ,EACRmC,aAAa,EACW;EACxB,OAAO,MAAM;IACX,IAAIA,aAAa,EAAE;MACjBA,aAAa,EAAE;IACrB;IAEI,MAAMf,YAAA,GAAe3B,QAAQ,CAACqB,IAAI,CAAC;IAEnC,IAAI,CAACM,YAAY,EAAE;MACjB;IACN;IAEI,MAAMqB,KAAA,GAAQrB,YAAY,CAACsB,OAAO,CAAC1C,QAAQ,CAAC;IAC5C,IAAIyC,KAAA,KAAU,EAAE,EAAE;MAChBrB,YAAY,CAACuB,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IACnC;EACA,CAAG;AACH;;AAEA;AACA;AACA;AACO,SAASG,wBAAwBA,CAACC,KAAK,EAAqD;EACjG,OAAO,cAAcA,KAAK;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}