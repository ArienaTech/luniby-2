{"ast":null,"code":"import { getIsolationScope, withIsolationScope } from '../../currentScopes.js';\nimport { fill } from '../../utils/object.js';\nimport { startInactiveSpan, withActiveSpan } from '../../tracing/trace.js';\nimport { extractSessionDataFromInitializeRequest, extractSessionDataFromInitializeResponse } from './attributeExtraction.js';\nimport { storeSpanForRequest, completeSpanWithResults, cleanupPendingSpansForTransport } from './correlation.js';\nimport { captureError } from './errorCapture.js';\nimport { storeSessionDataForTransport, updateSessionDataForTransport, cleanupSessionDataForTransport } from './sessionManagement.js';\nimport { buildMcpServerSpanConfig, createMcpNotificationSpan, createMcpOutgoingNotificationSpan } from './spans.js';\nimport { isJsonRpcRequest, isJsonRpcNotification, isJsonRpcResponse } from './validation.js';\n\n/**\n * Transport layer instrumentation for MCP server\n *\n * Handles message interception and response correlation.\n * @see https://modelcontextprotocol.io/specification/2025-06-18/basic/transports\n */\n\n/**\n * Wraps transport.onmessage to create spans for incoming messages.\n * For \"initialize\" requests, extracts and stores client info and protocol version\n * in the session data for the transport.\n * @param transport - MCP transport instance to wrap\n */\nfunction wrapTransportOnMessage(transport) {\n  if (transport.onmessage) {\n    fill(transport, 'onmessage', originalOnMessage => {\n      return function (message, extra) {\n        if (isJsonRpcRequest(message)) {\n          if (message.method === 'initialize') {\n            try {\n              const sessionData = extractSessionDataFromInitializeRequest(message);\n              storeSessionDataForTransport(this, sessionData);\n            } catch {\n              // noop\n            }\n          }\n          const isolationScope = getIsolationScope().clone();\n          return withIsolationScope(isolationScope, () => {\n            const spanConfig = buildMcpServerSpanConfig(message, this, extra);\n            const span = startInactiveSpan(spanConfig);\n            storeSpanForRequest(this, message.id, span, message.method);\n            return withActiveSpan(span, () => {\n              return originalOnMessage.call(this, message, extra);\n            });\n          });\n        }\n        if (isJsonRpcNotification(message)) {\n          return createMcpNotificationSpan(message, this, extra, () => {\n            return originalOnMessage.call(this, message, extra);\n          });\n        }\n        return originalOnMessage.call(this, message, extra);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport.send to handle outgoing messages and response correlation.\n * For \"initialize\" responses, extracts and stores protocol version and server info\n * in the session data for the transport.\n * @param transport - MCP transport instance to wrap\n */\nfunction wrapTransportSend(transport) {\n  if (transport.send) {\n    fill(transport, 'send', originalSend => {\n      return async function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const [message] = args;\n        if (isJsonRpcNotification(message)) {\n          return createMcpOutgoingNotificationSpan(message, this, () => {\n            return originalSend.call(this, ...args);\n          });\n        }\n        if (isJsonRpcResponse(message)) {\n          if (message.id !== null && message.id !== undefined) {\n            if (message.error) {\n              captureJsonRpcErrorResponse(message.error);\n            }\n            if (message.result && typeof message.result === 'object') {\n              const result = message.result;\n              if (result.protocolVersion || result.serverInfo) {\n                try {\n                  const serverData = extractSessionDataFromInitializeResponse(message.result);\n                  updateSessionDataForTransport(this, serverData);\n                } catch {\n                  // noop\n                }\n              }\n            }\n            completeSpanWithResults(this, message.id, message.result);\n          }\n        }\n        return originalSend.call(this, ...args);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport.onclose to clean up pending spans for this transport only\n * @param transport - MCP transport instance to wrap\n */\nfunction wrapTransportOnClose(transport) {\n  if (transport.onclose) {\n    fill(transport, 'onclose', originalOnClose => {\n      return function () {\n        cleanupPendingSpansForTransport(this);\n        cleanupSessionDataForTransport(this);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return originalOnClose.call(this, ...args);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport error handlers to capture connection errors\n * @param transport - MCP transport instance to wrap\n */\nfunction wrapTransportError(transport) {\n  if (transport.onerror) {\n    fill(transport, 'onerror', originalOnError => {\n      return function (error) {\n        captureTransportError(error);\n        return originalOnError.call(this, error);\n      };\n    });\n  }\n}\n\n/**\n * Captures JSON-RPC error responses for server-side errors.\n * @see https://www.jsonrpc.org/specification#error_object\n * @internal\n * @param errorResponse - JSON-RPC error response\n */\nfunction captureJsonRpcErrorResponse(errorResponse) {\n  try {\n    if (errorResponse && typeof errorResponse === 'object' && 'code' in errorResponse && 'message' in errorResponse) {\n      const jsonRpcError = errorResponse;\n      const isServerError = jsonRpcError.code === -32603 || jsonRpcError.code >= -32099 && jsonRpcError.code <= -32000;\n      if (isServerError) {\n        const error = new Error(jsonRpcError.message);\n        error.name = `JsonRpcError_${jsonRpcError.code}`;\n        captureError(error, 'protocol');\n      }\n    }\n  } catch {\n    // noop\n  }\n}\n\n/**\n * Captures transport connection errors\n * @internal\n * @param error - Transport error\n */\nfunction captureTransportError(error) {\n  try {\n    captureError(error, 'transport');\n  } catch {\n    // noop\n  }\n}\nexport { wrapTransportError, wrapTransportOnClose, wrapTransportOnMessage, wrapTransportSend };","map":{"version":3,"names":["wrapTransportOnMessage","transport","onmessage","fill","originalOnMessage","message","extra","isJsonRpcRequest","method","sessionData","extractSessionDataFromInitializeRequest","storeSessionDataForTransport","isolationScope","getIsolationScope","clone","withIsolationScope","spanConfig","buildMcpServerSpanConfig","span","startInactiveSpan","storeSpanForRequest","id","withActiveSpan","call","isJsonRpcNotification","createMcpNotificationSpan","wrapTransportSend","send","originalSend","_len","arguments","length","args","Array","_key","createMcpOutgoingNotificationSpan","isJsonRpcResponse","undefined","error","captureJsonRpcErrorResponse","result","protocolVersion","serverInfo","serverData","extractSessionDataFromInitializeResponse","updateSessionDataForTransport","completeSpanWithResults","wrapTransportOnClose","onclose","originalOnClose","cleanupPendingSpansForTransport","cleanupSessionDataForTransport","_len2","_key2","wrapTransportError","onerror","originalOnError","captureTransportError","errorResponse","jsonRpcError","isServerError","code","Error","name","captureError"],"sources":["/workspace/node_modules/@sentry/core/src/integrations/mcp-server/transport.ts"],"sourcesContent":["/**\n * Transport layer instrumentation for MCP server\n *\n * Handles message interception and response correlation.\n * @see https://modelcontextprotocol.io/specification/2025-06-18/basic/transports\n */\n\nimport { getIsolationScope, withIsolationScope } from '../../currentScopes';\nimport { startInactiveSpan, withActiveSpan } from '../../tracing';\nimport { fill } from '../../utils/object';\nimport {\n  extractSessionDataFromInitializeRequest,\n  extractSessionDataFromInitializeResponse,\n} from './attributeExtraction';\nimport { cleanupPendingSpansForTransport, completeSpanWithResults, storeSpanForRequest } from './correlation';\nimport { captureError } from './errorCapture';\nimport {\n  cleanupSessionDataForTransport,\n  storeSessionDataForTransport,\n  updateSessionDataForTransport,\n} from './sessionManagement';\nimport { buildMcpServerSpanConfig, createMcpNotificationSpan, createMcpOutgoingNotificationSpan } from './spans';\nimport type { ExtraHandlerData, MCPTransport } from './types';\nimport { isJsonRpcNotification, isJsonRpcRequest, isJsonRpcResponse } from './validation';\n\n/**\n * Wraps transport.onmessage to create spans for incoming messages.\n * For \"initialize\" requests, extracts and stores client info and protocol version\n * in the session data for the transport.\n * @param transport - MCP transport instance to wrap\n */\nexport function wrapTransportOnMessage(transport: MCPTransport): void {\n  if (transport.onmessage) {\n    fill(transport, 'onmessage', originalOnMessage => {\n      return function (this: MCPTransport, message: unknown, extra?: unknown) {\n        if (isJsonRpcRequest(message)) {\n          if (message.method === 'initialize') {\n            try {\n              const sessionData = extractSessionDataFromInitializeRequest(message);\n              storeSessionDataForTransport(this, sessionData);\n            } catch {\n              // noop\n            }\n          }\n\n          const isolationScope = getIsolationScope().clone();\n\n          return withIsolationScope(isolationScope, () => {\n            const spanConfig = buildMcpServerSpanConfig(message, this, extra as ExtraHandlerData);\n            const span = startInactiveSpan(spanConfig);\n\n            storeSpanForRequest(this, message.id, span, message.method);\n\n            return withActiveSpan(span, () => {\n              return (originalOnMessage as (...args: unknown[]) => unknown).call(this, message, extra);\n            });\n          });\n        }\n\n        if (isJsonRpcNotification(message)) {\n          return createMcpNotificationSpan(message, this, extra as ExtraHandlerData, () => {\n            return (originalOnMessage as (...args: unknown[]) => unknown).call(this, message, extra);\n          });\n        }\n\n        return (originalOnMessage as (...args: unknown[]) => unknown).call(this, message, extra);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport.send to handle outgoing messages and response correlation.\n * For \"initialize\" responses, extracts and stores protocol version and server info\n * in the session data for the transport.\n * @param transport - MCP transport instance to wrap\n */\nexport function wrapTransportSend(transport: MCPTransport): void {\n  if (transport.send) {\n    fill(transport, 'send', originalSend => {\n      return async function (this: MCPTransport, ...args: unknown[]) {\n        const [message] = args;\n\n        if (isJsonRpcNotification(message)) {\n          return createMcpOutgoingNotificationSpan(message, this, () => {\n            return (originalSend as (...args: unknown[]) => unknown).call(this, ...args);\n          });\n        }\n\n        if (isJsonRpcResponse(message)) {\n          if (message.id !== null && message.id !== undefined) {\n            if (message.error) {\n              captureJsonRpcErrorResponse(message.error);\n            }\n\n            if (message.result && typeof message.result === 'object') {\n              const result = message.result as Record<string, unknown>;\n              if (result.protocolVersion || result.serverInfo) {\n                try {\n                  const serverData = extractSessionDataFromInitializeResponse(message.result);\n                  updateSessionDataForTransport(this, serverData);\n                } catch {\n                  // noop\n                }\n              }\n            }\n\n            completeSpanWithResults(this, message.id, message.result);\n          }\n        }\n\n        return (originalSend as (...args: unknown[]) => unknown).call(this, ...args);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport.onclose to clean up pending spans for this transport only\n * @param transport - MCP transport instance to wrap\n */\nexport function wrapTransportOnClose(transport: MCPTransport): void {\n  if (transport.onclose) {\n    fill(transport, 'onclose', originalOnClose => {\n      return function (this: MCPTransport, ...args: unknown[]) {\n        cleanupPendingSpansForTransport(this);\n        cleanupSessionDataForTransport(this);\n        return (originalOnClose as (...args: unknown[]) => unknown).call(this, ...args);\n      };\n    });\n  }\n}\n\n/**\n * Wraps transport error handlers to capture connection errors\n * @param transport - MCP transport instance to wrap\n */\nexport function wrapTransportError(transport: MCPTransport): void {\n  if (transport.onerror) {\n    fill(transport, 'onerror', (originalOnError: (error: Error) => void) => {\n      return function (this: MCPTransport, error: Error) {\n        captureTransportError(error);\n        return originalOnError.call(this, error);\n      };\n    });\n  }\n}\n\n/**\n * Captures JSON-RPC error responses for server-side errors.\n * @see https://www.jsonrpc.org/specification#error_object\n * @internal\n * @param errorResponse - JSON-RPC error response\n */\nfunction captureJsonRpcErrorResponse(errorResponse: unknown): void {\n  try {\n    if (errorResponse && typeof errorResponse === 'object' && 'code' in errorResponse && 'message' in errorResponse) {\n      const jsonRpcError = errorResponse as { code: number; message: string; data?: unknown };\n\n      const isServerError =\n        jsonRpcError.code === -32603 || (jsonRpcError.code >= -32099 && jsonRpcError.code <= -32000);\n\n      if (isServerError) {\n        const error = new Error(jsonRpcError.message);\n        error.name = `JsonRpcError_${jsonRpcError.code}`;\n\n        captureError(error, 'protocol');\n      }\n    }\n  } catch {\n    // noop\n  }\n}\n\n/**\n * Captures transport connection errors\n * @internal\n * @param error - Transport error\n */\nfunction captureTransportError(error: Error): void {\n  try {\n    captureError(error, 'transport');\n  } catch {\n    // noop\n  }\n}\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,sBAAsBA,CAACC,SAAS,EAAsB;EACpE,IAAIA,SAAS,CAACC,SAAS,EAAE;IACvBC,IAAI,CAACF,SAAS,EAAE,WAAW,EAAEG,iBAAA,IAAqB;MAChD,OAAO,UAA8BC,OAAO,EAAWC,KAAK,EAAY;QACtE,IAAIC,gBAAgB,CAACF,OAAO,CAAC,EAAE;UAC7B,IAAIA,OAAO,CAACG,MAAA,KAAW,YAAY,EAAE;YACnC,IAAI;cACF,MAAMC,WAAA,GAAcC,uCAAuC,CAACL,OAAO,CAAC;cACpEM,4BAA4B,CAAC,IAAI,EAAEF,WAAW,CAAC;YAC7D,EAAc,MAAM;cACpB;YAAA;UAEA;UAEU,MAAMG,cAAA,GAAiBC,iBAAiB,EAAE,CAACC,KAAK,EAAE;UAElD,OAAOC,kBAAkB,CAACH,cAAc,EAAE,MAAM;YAC9C,MAAMI,UAAA,GAAaC,wBAAwB,CAACZ,OAAO,EAAE,IAAI,EAAEC,KAAA,CAA0B;YACrF,MAAMY,IAAA,GAAOC,iBAAiB,CAACH,UAAU,CAAC;YAE1CI,mBAAmB,CAAC,IAAI,EAAEf,OAAO,CAACgB,EAAE,EAAEH,IAAI,EAAEb,OAAO,CAACG,MAAM,CAAC;YAE3D,OAAOc,cAAc,CAACJ,IAAI,EAAE,MAAM;cAChC,OAAQd,iBAAA,CAAsDmB,IAAI,CAAC,IAAI,EAAElB,OAAO,EAAEC,KAAK,CAAC;YACtG,CAAa,CAAC;UACd,CAAW,CAAC;QACZ;QAEQ,IAAIkB,qBAAqB,CAACnB,OAAO,CAAC,EAAE;UAClC,OAAOoB,yBAAyB,CAACpB,OAAO,EAAE,IAAI,EAAEC,KAAA,EAA2B,MAAM;YAC/E,OAAQF,iBAAA,CAAsDmB,IAAI,CAAC,IAAI,EAAElB,OAAO,EAAEC,KAAK,CAAC;UACpG,CAAW,CAAC;QACZ;QAEQ,OAAQF,iBAAA,CAAsDmB,IAAI,CAAC,IAAI,EAAElB,OAAO,EAAEC,KAAK,CAAC;MAChG,CAAO;IACP,CAAK,CAAC;EACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoB,iBAAiBA,CAACzB,SAAS,EAAsB;EAC/D,IAAIA,SAAS,CAAC0B,IAAI,EAAE;IAClBxB,IAAI,CAACF,SAAS,EAAE,MAAM,EAAE2B,YAAA,IAAgB;MACtC,OAAO,kBAAwD;QAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAjBC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;UAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;QAAA;QAChD,MAAM,CAAC7B,OAAO,IAAI2B,IAAI;QAEtB,IAAIR,qBAAqB,CAACnB,OAAO,CAAC,EAAE;UAClC,OAAO8B,iCAAiC,CAAC9B,OAAO,EAAE,IAAI,EAAE,MAAM;YAC5D,OAAQuB,YAAA,CAAiDL,IAAI,CAAC,IAAI,EAAE,GAAGS,IAAI,CAAC;UACxF,CAAW,CAAC;QACZ;QAEQ,IAAII,iBAAiB,CAAC/B,OAAO,CAAC,EAAE;UAC9B,IAAIA,OAAO,CAACgB,EAAA,KAAO,QAAQhB,OAAO,CAACgB,EAAA,KAAOgB,SAAS,EAAE;YACnD,IAAIhC,OAAO,CAACiC,KAAK,EAAE;cACjBC,2BAA2B,CAAClC,OAAO,CAACiC,KAAK,CAAC;YACxD;YAEY,IAAIjC,OAAO,CAACmC,MAAA,IAAU,OAAOnC,OAAO,CAACmC,MAAA,KAAW,QAAQ,EAAE;cACxD,MAAMA,MAAA,GAASnC,OAAO,CAACmC,MAAA;cACvB,IAAIA,MAAM,CAACC,eAAA,IAAmBD,MAAM,CAACE,UAAU,EAAE;gBAC/C,IAAI;kBACF,MAAMC,UAAA,GAAaC,wCAAwC,CAACvC,OAAO,CAACmC,MAAM,CAAC;kBAC3EK,6BAA6B,CAAC,IAAI,EAAEF,UAAU,CAAC;gBACjE,EAAkB,MAAM;kBACxB;gBAAA;cAEA;YACA;YAEYG,uBAAuB,CAAC,IAAI,EAAEzC,OAAO,CAACgB,EAAE,EAAEhB,OAAO,CAACmC,MAAM,CAAC;UACrE;QACA;QAEQ,OAAQZ,YAAA,CAAiDL,IAAI,CAAC,IAAI,EAAE,GAAGS,IAAI,CAAC;MACpF,CAAO;IACP,CAAK,CAAC;EACN;AACA;;AAEA;AACA;AACA;AACA;AACO,SAASe,oBAAoBA,CAAC9C,SAAS,EAAsB;EAClE,IAAIA,SAAS,CAAC+C,OAAO,EAAE;IACrB7C,IAAI,CAACF,SAAS,EAAE,SAAS,EAAEgD,eAAA,IAAmB;MAC5C,OAAO,YAAkD;QACvDC,+BAA+B,CAAC,IAAI,CAAC;QACrCC,8BAA8B,CAAC,IAAI,CAAC;QAAA,SAAAC,KAAA,GAAAtB,SAAA,CAAAC,MAAA,EAFEC,IAAI,OAAAC,KAAA,CAAAmB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAJrB,IAAI,CAAAqB,KAAA,IAAAvB,SAAA,CAAAuB,KAAA;QAAA;QAG1C,OAAQJ,eAAA,CAAoD1B,IAAI,CAAC,IAAI,EAAE,GAAGS,IAAI,CAAC;MACvF,CAAO;IACP,CAAK,CAAC;EACN;AACA;;AAEA;AACA;AACA;AACA;AACO,SAASsB,kBAAkBA,CAACrD,SAAS,EAAsB;EAChE,IAAIA,SAAS,CAACsD,OAAO,EAAE;IACrBpD,IAAI,CAACF,SAAS,EAAE,SAAS,EAAGuD,eAAe,IAA6B;MACtE,OAAO,UAA8BlB,KAAK,EAAS;QACjDmB,qBAAqB,CAACnB,KAAK,CAAC;QAC5B,OAAOkB,eAAe,CAACjC,IAAI,CAAC,IAAI,EAAEe,KAAK,CAAC;MAChD,CAAO;IACP,CAAK,CAAC;EACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACmB,aAAa,EAAiB;EACjE,IAAI;IACF,IAAIA,aAAA,IAAiB,OAAOA,aAAA,KAAkB,YAAY,UAAUA,aAAA,IAAiB,aAAaA,aAAa,EAAE;MAC/G,MAAMC,YAAA,GAAeD,aAAA;MAErB,MAAME,aAAA,GACJD,YAAY,CAACE,IAAA,KAAS,CAAC,SAAUF,YAAY,CAACE,IAAA,IAAQ,CAAC,SAASF,YAAY,CAACE,IAAA,IAAQ,CAAC,KAAM;MAE9F,IAAID,aAAa,EAAE;QACjB,MAAMtB,KAAA,GAAQ,IAAIwB,KAAK,CAACH,YAAY,CAACtD,OAAO,CAAC;QAC7CiC,KAAK,CAACyB,IAAA,GAAO,gBAAgBJ,YAAY,CAACE,IAAI,EAAC;QAEAG,YAAA,CAAA1B,KAAA;MACA;IACA;EACA;IACA;EAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAAmB,sBAAAnB,KAAA;EACA;IACA0B,YAAA,CAAA1B,KAAA;EACA;IACA;EAAA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}