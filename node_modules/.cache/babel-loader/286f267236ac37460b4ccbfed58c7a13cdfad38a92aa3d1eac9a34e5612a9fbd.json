{"ast":null,"code":"const STACKTRACE_FRAME_LIMIT = 50;\nconst UNKNOWN_FUNCTION = '?';\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser() {\n  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n    parsers[_key] = arguments[_key];\n  }\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n  return function (stack) {\n    let skipFirstLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let framesToPop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const frames = [];\n    const lines = stack.split('\\n');\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      let line = lines[i];\n      // Truncate lines over 1kb because many of the regular expressions use\n      // backtracking which results in run time that increases exponentially\n      // with input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        line = line.slice(0, 1024);\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n        break;\n      }\n    }\n    return stripSentryFramesAndReverse(frames.slice(framesToPop));\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  const localStack = Array.from(stack);\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n\n    // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n    // is produced within the scope itself, making it:\n    //\n    //   Sentry.captureException()\n    //   scope.captureException()\n    //\n    // instead of just the top `Sentry` call itself.\n    // This forces us to possibly strip an additional frame in the exact same was as above.\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n      localStack.pop();\n    }\n  }\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION\n  }));\n}\nfunction getLastStackFrame(arr) {\n  return arr[arr.length - 1] || {};\n}\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Get's stack frames from an event without needing to check for undefined properties.\n */\nfunction getFramesFromEvent(event) {\n  const exception = event.exception;\n  if (exception) {\n    const frames = [];\n    try {\n      // @ts-expect-error Object could be undefined\n      exception.values.forEach(value => {\n        // @ts-expect-error Value could be undefined\n        if (value.stacktrace.frames) {\n          // @ts-expect-error Value could be undefined\n          frames.push(...value.stacktrace.frames);\n        }\n      });\n      return frames;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\nexport { UNKNOWN_FUNCTION, createStackParser, getFramesFromEvent, getFunctionName, stackParserFromStackParserOptions, stripSentryFramesAndReverse };","map":{"version":3,"names":["STACKTRACE_FRAME_LIMIT","UNKNOWN_FUNCTION","WEBPACK_ERROR_REGEXP","STRIP_FRAME_REGEXP","createStackParser","_len","arguments","length","parsers","Array","_key","sortedParsers","sort","a","b","map","p","stack","skipFirstLines","undefined","framesToPop","frames","lines","split","i","line","slice","cleanedLine","test","replace","match","parser","frame","push","stripSentryFramesAndReverse","stackParserFromStackParserOptions","stackParser","isArray","localStack","from","getLastStackFrame","function","pop","reverse","filename","arr","defaultFunctionName","getFunctionName","fn","name","getFramesFromEvent","event","exception","values","forEach","value","stacktrace"],"sources":["/workspace/node_modules/@sentry/core/src/utils/stacktrace.ts"],"sourcesContent":["import type { Event } from '../types-hoist/event';\nimport type { StackFrame } from '../types-hoist/stackframe';\nimport type { StackLineParser, StackParser } from '../types-hoist/stacktrace';\n\nconst STACKTRACE_FRAME_LIMIT = 50;\nexport const UNKNOWN_FUNCTION = '?';\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirstLines: number = 0, framesToPop: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      let line = lines[i] as string;\n      // Truncate lines over 1kb because many of the regular expressions use\n      // backtracking which results in run time that increases exponentially\n      // with input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        line = line.slice(0, 1024);\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames.slice(framesToPop));\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nexport function stackParserFromStackParserOptions(stackParser: StackParser | StackLineParser[]): StackParser {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: ReadonlyArray<StackFrame>): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = Array.from(stack);\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n\n    // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n    // is produced within the scope itself, making it:\n    //\n    //   Sentry.captureException()\n    //   scope.captureException()\n    //\n    // instead of just the top `Sentry` call itself.\n    // This forces us to possibly strip an additional frame in the exact same was as above.\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n      localStack.pop();\n    }\n  }\n\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION,\n  }));\n}\n\nfunction getLastStackFrame(arr: StackFrame[]): StackFrame {\n  return arr[arr.length - 1] || {};\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Get's stack frames from an event without needing to check for undefined properties.\n */\nexport function getFramesFromEvent(event: Event): StackFrame[] | undefined {\n  const exception = event.exception;\n\n  if (exception) {\n    const frames: StackFrame[] = [];\n    try {\n      // @ts-expect-error Object could be undefined\n      exception.values.forEach(value => {\n        // @ts-expect-error Value could be undefined\n        if (value.stacktrace.frames) {\n          // @ts-expect-error Value could be undefined\n          frames.push(...value.stacktrace.frames);\n        }\n      });\n      return frames;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}