{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { forEachEnvelopeItem, envelopeItemTypeToDataCategory, createEnvelope, serializeEnvelope } from '../utils/envelope.js';\nimport { makePromiseBuffer, SENTRY_BUFFER_FULL_ERROR } from '../utils/promisebuffer.js';\nimport { isRateLimited, updateRateLimits } from '../utils/ratelimit.js';\nimport { resolvedSyncPromise } from '../utils/syncpromise.js';\nconst DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(options, makeRequest) {\n  let buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  let rateLimits = {};\n  const flush = timeout => buffer.drain(timeout);\n  function send(envelope) {\n    const filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const dataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise({});\n    }\n    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = reason => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n    const requestTask = () => makeRequest({\n      body: serializeEnvelope(filteredEnvelope)\n    }).then(response => {\n      // We don't want to throw on NOK responses, but we want to at least log them\n      if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n        DEBUG_BUILD && debug.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n      }\n      rateLimits = updateRateLimits(rateLimits, response);\n      return response;\n    }, error => {\n      recordEnvelopeLoss('network_error');\n      DEBUG_BUILD && debug.error('Encountered error running transport request:', error);\n      throw error;\n    });\n    return buffer.add(requestTask).then(result => result, error => {\n      if (error === SENTRY_BUFFER_FULL_ERROR) {\n        DEBUG_BUILD && debug.error('Skipped sending event because buffer is full.');\n        recordEnvelopeLoss('queue_overflow');\n        return resolvedSyncPromise({});\n      } else {\n        throw error;\n      }\n    });\n  }\n  return {\n    send,\n    flush\n  };\n}\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };","map":{"version":3,"names":["DEFAULT_TRANSPORT_BUFFER_SIZE","createTransport","options","makeRequest","buffer","arguments","length","undefined","makePromiseBuffer","bufferSize","rateLimits","flush","timeout","drain","send","envelope","filteredEnvelopeItems","forEachEnvelopeItem","item","type","dataCategory","envelopeItemTypeToDataCategory","isRateLimited","recordDroppedEvent","push","resolvedSyncPromise","filteredEnvelope","createEnvelope","recordEnvelopeLoss","reason","requestTask","body","serializeEnvelope","then","response","statusCode","DEBUG_BUILD","debug","warn","updateRateLimits","error","add","result","SENTRY_BUFFER_FULL_ERROR"],"sources":["/workspace/node_modules/@sentry/core/src/transports/base.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { EventDropReason } from '../types-hoist/clientreport';\nimport type { Envelope, EnvelopeItem } from '../types-hoist/envelope';\nimport type {\n  InternalBaseTransportOptions,\n  Transport,\n  TransportMakeRequestResponse,\n  TransportRequestExecutor,\n} from '../types-hoist/transport';\nimport { debug } from '../utils/debug-logger';\nimport {\n  createEnvelope,\n  envelopeItemTypeToDataCategory,\n  forEachEnvelopeItem,\n  serializeEnvelope,\n} from '../utils/envelope';\nimport { type PromiseBuffer, makePromiseBuffer, SENTRY_BUFFER_FULL_ERROR } from '../utils/promisebuffer';\nimport { type RateLimits, isRateLimited, updateRateLimits } from '../utils/ratelimit';\nimport { resolvedSyncPromise } from '../utils/syncpromise';\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportMakeRequestResponse> = makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,\n  ),\n): Transport {\n  let rateLimits: RateLimits = {};\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportMakeRequestResponse> {\n    const filteredEnvelopeItems: EnvelopeItem[] = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const dataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise({});\n    }\n\n    const filteredEnvelope: Envelope = createEnvelope(envelope[0], filteredEnvelopeItems as (typeof envelope)[1]);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason: EventDropReason): void => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    const requestTask = (): PromiseLike<TransportMakeRequestResponse> =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            DEBUG_BUILD && debug.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n          return response;\n        },\n        error => {\n          recordEnvelopeLoss('network_error');\n          DEBUG_BUILD && debug.error('Encountered error running transport request:', error);\n          throw error;\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error === SENTRY_BUFFER_FULL_ERROR) {\n          DEBUG_BUILD && debug.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return resolvedSyncPromise({});\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n"],"mappings":";;;;;;AAoBO,MAAMA,6BAAA,GAAgC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,eAAeA,CAC7BC,OAAO,EACPC,WAAW,EAIA;EAAA,IAHXC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgDG,iBAAiB,CACrEN,OAAO,CAACO,UAAA,IAAcT,6BAC1B,CAAG;EAED,IAAIU,UAAU,GAAe,EAAE;EAC/B,MAAMC,KAAA,GAASC,OAAO,IAAoCR,MAAM,CAACS,KAAK,CAACD,OAAO,CAAC;EAE/E,SAASE,IAAIA,CAACC,QAAQ,EAAuD;IAC3E,MAAMC,qBAAqB,GAAmB,EAAE;;IAEpD;IACIC,mBAAmB,CAACF,QAAQ,EAAE,CAACG,IAAI,EAAEC,IAAI,KAAK;MAC5C,MAAMC,YAAA,GAAeC,8BAA8B,CAACF,IAAI,CAAC;MACzD,IAAIG,aAAa,CAACZ,UAAU,EAAEU,YAAY,CAAC,EAAE;QAC3ClB,OAAO,CAACqB,kBAAkB,CAAC,mBAAmB,EAAEH,YAAY,CAAC;MACrE,OAAa;QACLJ,qBAAqB,CAACQ,IAAI,CAACN,IAAI,CAAC;MACxC;IACA,CAAK,CAAC;;IAEN;IACI,IAAIF,qBAAqB,CAACV,MAAA,KAAW,CAAC,EAAE;MACtC,OAAOmB,mBAAmB,CAAC,EAAE,CAAC;IACpC;IAEI,MAAMC,gBAAgB,GAAaC,cAAc,CAACZ,QAAQ,CAAC,CAAC,CAAC,EAAEC,qBAAA,CAA8C;;IAEjH;IACI,MAAMY,kBAAA,GAAsBC,MAAM,IAA4B;MAC5DZ,mBAAmB,CAACS,gBAAgB,EAAE,CAACR,IAAI,EAAEC,IAAI,KAAK;QACpDjB,OAAO,CAACqB,kBAAkB,CAACM,MAAM,EAAER,8BAA8B,CAACF,IAAI,CAAC,CAAC;MAChF,CAAO,CAAC;IACR,CAAK;IAED,MAAMW,WAAA,GAAcA,CAAA,KAClB3B,WAAW,CAAC;MAAE4B,IAAI,EAAEC,iBAAiB,CAACN,gBAAgB;IAAA,CAAG,CAAC,CAACO,IAAI,CAC7DC,QAAA,IAAY;MACpB;MACU,IAAIA,QAAQ,CAACC,UAAA,KAAe5B,SAAA,KAAc2B,QAAQ,CAACC,UAAA,GAAa,OAAOD,QAAQ,CAACC,UAAA,IAAc,GAAG,CAAC,EAAE;QAClGC,WAAA,IAAeC,KAAK,CAACC,IAAI,CAAC,qCAAqCJ,QAAQ,CAACC,UAAU,iBAAiB,CAAC;MAChH;MAEUzB,UAAA,GAAa6B,gBAAgB,CAAC7B,UAAU,EAAEwB,QAAQ,CAAC;MACnD,OAAOA,QAAQ;IACzB,CAAS,EACDM,KAAA,IAAS;MACPZ,kBAAkB,CAAC,eAAe,CAAC;MACnCQ,WAAA,IAAeC,KAAK,CAACG,KAAK,CAAC,8CAA8C,EAAEA,KAAK,CAAC;MACjF,MAAMA,KAAK;IACrB,CACA,CAAO;IAEH,OAAOpC,MAAM,CAACqC,GAAG,CAACX,WAAW,CAAC,CAACG,IAAI,CACjCS,MAAA,IAAUA,MAAM,EAChBF,KAAA,IAAS;MACP,IAAIA,KAAA,KAAUG,wBAAwB,EAAE;QACtCP,WAAA,IAAeC,KAAK,CAACG,KAAK,CAAC,+CAA+C,CAAC;QAC3EZ,kBAAkB,CAAC,gBAAgB,CAAC;QACpC,OAAOH,mBAAmB,CAAC,EAAE,CAAC;MACxC,OAAe;QACL,MAAMe,KAAK;MACrB;IACA,CACA,CAAK;EACL;EAEE,OAAO;IACL1B,IAAI;IACJH;EACJ,CAAG;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}