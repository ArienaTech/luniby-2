{"ast":null,"code":"// Supabase utility functions for common operations\nimport{supabase}from'./supabase';/**\n * Handle Supabase errors consistently\n * @param {Object} error - The error object from Supabase\n * @param {string} defaultMessage - Default message if error is not specific\n * @returns {string} - User-friendly error message\n */export const handleSupabaseError=function(error){let defaultMessage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'An error occurred';if(!error)return defaultMessage;// Handle specific error codes\nif(error.message){// Auth errors\nif(error.message.includes('Invalid login credentials')){return'Invalid email or password';}if(error.message.includes('Email not confirmed')){return'Please verify your email address before signing in';}if(error.message.includes('User already registered')){return'An account with this email already exists';}if(error.message.includes('Auth session missing')){return'Your session has expired. Please sign in again';}// Database errors\nif(error.message.includes('duplicate key value')){return'This record already exists';}if(error.message.includes('violates foreign key constraint')){return'Cannot complete this action due to related records';}if(error.message.includes('relation')&&error.message.includes('does not exist')){return'Database table not found. Please contact support';}// Network errors\nif(error.message.includes('Failed to fetch')||error.message.includes('Network request failed')){return'Network error. Please check your connection and try again';}// Return the original error message if it's user-friendly\nreturn error.message;}return defaultMessage;};/**\n * Get the current user safely with error handling\n * @returns {Promise<{user: Object|null, error: string|null}>}\n */export const getUserSafely=async()=>{try{const{data:{user},error}=await supabase.auth.getUser();if(error){console.error('Error getting user:',error);return{user:null,error:handleSupabaseError(error)};}return{user,error:null};}catch(error){console.error('Exception getting user:',error);return{user:null,error:'Failed to get user information'};}};/**\n * Sign in with retry logic for better reliability\n * @param {string} email - User email\n * @param {string} password - User password\n * @param {number} maxRetries - Maximum number of retry attempts\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */export const signInWithRetry=async function(email,password){let maxRetries=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;let lastError=null;for(let attempt=0;attempt<=maxRetries;attempt++){try{const{data,error}=await supabase.auth.signInWithPassword({email,password});if(error){lastError=error;// Don't retry on authentication errors (wrong credentials)\nif(error.message.includes('Invalid login credentials')||error.message.includes('Email not confirmed')){return{data:null,error:handleSupabaseError(error)};}// Wait before retrying on network errors\nif(attempt<maxRetries){await new Promise(resolve=>setTimeout(resolve,1000*(attempt+1)));continue;}}else{return{data,error:null};}}catch(error){lastError=error;// Wait before retrying\nif(attempt<maxRetries){await new Promise(resolve=>setTimeout(resolve,1000*(attempt+1)));continue;}}}return{data:null,error:handleSupabaseError(lastError,'Sign in failed. Please try again')};};/**\n * Create a realtime subscription with automatic cleanup\n * @param {string} table - Table name to subscribe to\n * @param {Function} callback - Callback function for changes\n * @param {Object} filter - Optional filter object\n * @returns {Function} - Cleanup function to unsubscribe\n */export const createRealtimeSubscription=function(table,callback){let filter=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let subscription=null;try{let query=supabase.channel(`${table}_changes`).on('postgres_changes',{event:'*',schema:'public',table:table,...filter},payload=>{console.log(`Realtime update on ${table}:`,payload);callback(payload);});subscription=query.subscribe(status=>{console.log(`Subscription status for ${table}:`,status);});// Return cleanup function\nreturn()=>{if(subscription){console.log(`Unsubscribing from ${table}`);supabase.removeChannel(subscription);}};}catch(error){console.error(`Error creating realtime subscription for ${table}:`,error);return()=>{};// Return empty cleanup function\n}};/**\n * Safely query a table with error handling\n * @param {string} table - Table name\n * @param {string} columns - Columns to select (default: *)\n * @returns {Promise<{data: Array, error: string|null}>}\n */export const queryTable=async function(table){let columns=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'*';try{const{data,error}=await supabase.from(table).select(columns);if(error){return{data:[],error:handleSupabaseError(error)};}return{data:data||[],error:null};}catch(error){return{data:[],error:handleSupabaseError(error,'Failed to query data')};}};/**\n * Safely insert data into a table\n * @param {string} table - Table name\n * @param {Object|Array} data - Data to insert\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */export const insertIntoTable=async(table,data)=>{try{const{data:result,error}=await supabase.from(table).insert(data).select();if(error){return{data:null,error:handleSupabaseError(error)};}return{data:result,error:null};}catch(error){return{data:null,error:handleSupabaseError(error,'Failed to insert data')};}};/**\n * Safely update data in a table\n * @param {string} table - Table name\n * @param {Object} updates - Data to update\n * @param {Object} match - Match criteria\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */export const updateInTable=async(table,updates,match)=>{try{let query=supabase.from(table).update(updates);// Apply match criteria\nObject.entries(match).forEach(_ref=>{let[key,value]=_ref;query=query.eq(key,value);});const{data,error}=await query.select();if(error){return{data:null,error:handleSupabaseError(error)};}return{data,error:null};}catch(error){return{data:null,error:handleSupabaseError(error,'Failed to update data')};}};/**\n * Check if a table exists by trying to query it\n * @param {string} table - Table name\n * @returns {Promise<boolean>}\n */export const tableExists=async table=>{try{const{error}=await supabase.from(table).select('*').limit(1);if(error&&error.message.includes('does not exist')){return false;}return true;}catch(error){return false;}};export default{handleSupabaseError,getUserSafely,signInWithRetry,createRealtimeSubscription,queryTable,insertIntoTable,updateInTable,tableExists};","map":{"version":3,"names":["supabase","handleSupabaseError","error","defaultMessage","arguments","length","undefined","message","includes","getUserSafely","data","user","auth","getUser","console","signInWithRetry","email","password","maxRetries","lastError","attempt","signInWithPassword","Promise","resolve","setTimeout","createRealtimeSubscription","table","callback","filter","subscription","query","channel","on","event","schema","payload","log","subscribe","status","removeChannel","queryTable","columns","from","select","insertIntoTable","result","insert","updateInTable","updates","match","update","Object","entries","forEach","_ref","key","value","eq","tableExists","limit"],"sources":["/workspace/src/lib/supabase-utils.js"],"sourcesContent":["// Supabase utility functions for common operations\nimport { supabase } from './supabase';\n\n/**\n * Handle Supabase errors consistently\n * @param {Object} error - The error object from Supabase\n * @param {string} defaultMessage - Default message if error is not specific\n * @returns {string} - User-friendly error message\n */\nexport const handleSupabaseError = (error, defaultMessage = 'An error occurred') => {\n  if (!error) return defaultMessage;\n\n  // Handle specific error codes\n  if (error.message) {\n    // Auth errors\n    if (error.message.includes('Invalid login credentials')) {\n      return 'Invalid email or password';\n    }\n    if (error.message.includes('Email not confirmed')) {\n      return 'Please verify your email address before signing in';\n    }\n    if (error.message.includes('User already registered')) {\n      return 'An account with this email already exists';\n    }\n    if (error.message.includes('Auth session missing')) {\n      return 'Your session has expired. Please sign in again';\n    }\n    \n    // Database errors\n    if (error.message.includes('duplicate key value')) {\n      return 'This record already exists';\n    }\n    if (error.message.includes('violates foreign key constraint')) {\n      return 'Cannot complete this action due to related records';\n    }\n    if (error.message.includes('relation') && error.message.includes('does not exist')) {\n      return 'Database table not found. Please contact support';\n    }\n    \n    // Network errors\n    if (error.message.includes('Failed to fetch') || error.message.includes('Network request failed')) {\n      return 'Network error. Please check your connection and try again';\n    }\n    \n    // Return the original error message if it's user-friendly\n    return error.message;\n  }\n\n  return defaultMessage;\n};\n\n/**\n * Get the current user safely with error handling\n * @returns {Promise<{user: Object|null, error: string|null}>}\n */\nexport const getUserSafely = async () => {\n  try {\n    const { data: { user }, error } = await supabase.auth.getUser();\n    \n    if (error) {\n      console.error('Error getting user:', error);\n      return { user: null, error: handleSupabaseError(error) };\n    }\n    \n    return { user, error: null };\n  } catch (error) {\n    console.error('Exception getting user:', error);\n    return { user: null, error: 'Failed to get user information' };\n  }\n};\n\n/**\n * Sign in with retry logic for better reliability\n * @param {string} email - User email\n * @param {string} password - User password\n * @param {number} maxRetries - Maximum number of retry attempts\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */\nexport const signInWithRetry = async (email, password, maxRetries = 2) => {\n  let lastError = null;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n      });\n      \n      if (error) {\n        lastError = error;\n        \n        // Don't retry on authentication errors (wrong credentials)\n        if (error.message.includes('Invalid login credentials') || \n            error.message.includes('Email not confirmed')) {\n          return { data: null, error: handleSupabaseError(error) };\n        }\n        \n        // Wait before retrying on network errors\n        if (attempt < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n          continue;\n        }\n      } else {\n        return { data, error: null };\n      }\n    } catch (error) {\n      lastError = error;\n      \n      // Wait before retrying\n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n        continue;\n      }\n    }\n  }\n  \n  return { data: null, error: handleSupabaseError(lastError, 'Sign in failed. Please try again') };\n};\n\n/**\n * Create a realtime subscription with automatic cleanup\n * @param {string} table - Table name to subscribe to\n * @param {Function} callback - Callback function for changes\n * @param {Object} filter - Optional filter object\n * @returns {Function} - Cleanup function to unsubscribe\n */\nexport const createRealtimeSubscription = (table, callback, filter = {}) => {\n  let subscription = null;\n  \n  try {\n    let query = supabase\n      .channel(`${table}_changes`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: table,\n          ...filter\n        },\n        (payload) => {\n          console.log(`Realtime update on ${table}:`, payload);\n          callback(payload);\n        }\n      );\n    \n    subscription = query.subscribe((status) => {\n      console.log(`Subscription status for ${table}:`, status);\n    });\n    \n    // Return cleanup function\n    return () => {\n      if (subscription) {\n        console.log(`Unsubscribing from ${table}`);\n        supabase.removeChannel(subscription);\n      }\n    };\n  } catch (error) {\n    console.error(`Error creating realtime subscription for ${table}:`, error);\n    return () => {}; // Return empty cleanup function\n  }\n};\n\n/**\n * Safely query a table with error handling\n * @param {string} table - Table name\n * @param {string} columns - Columns to select (default: *)\n * @returns {Promise<{data: Array, error: string|null}>}\n */\nexport const queryTable = async (table, columns = '*') => {\n  try {\n    const { data, error } = await supabase\n      .from(table)\n      .select(columns);\n    \n    if (error) {\n      return { data: [], error: handleSupabaseError(error) };\n    }\n    \n    return { data: data || [], error: null };\n  } catch (error) {\n    return { data: [], error: handleSupabaseError(error, 'Failed to query data') };\n  }\n};\n\n/**\n * Safely insert data into a table\n * @param {string} table - Table name\n * @param {Object|Array} data - Data to insert\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */\nexport const insertIntoTable = async (table, data) => {\n  try {\n    const { data: result, error } = await supabase\n      .from(table)\n      .insert(data)\n      .select();\n    \n    if (error) {\n      return { data: null, error: handleSupabaseError(error) };\n    }\n    \n    return { data: result, error: null };\n  } catch (error) {\n    return { data: null, error: handleSupabaseError(error, 'Failed to insert data') };\n  }\n};\n\n/**\n * Safely update data in a table\n * @param {string} table - Table name\n * @param {Object} updates - Data to update\n * @param {Object} match - Match criteria\n * @returns {Promise<{data: Object|null, error: string|null}>}\n */\nexport const updateInTable = async (table, updates, match) => {\n  try {\n    let query = supabase\n      .from(table)\n      .update(updates);\n    \n    // Apply match criteria\n    Object.entries(match).forEach(([key, value]) => {\n      query = query.eq(key, value);\n    });\n    \n    const { data, error } = await query.select();\n    \n    if (error) {\n      return { data: null, error: handleSupabaseError(error) };\n    }\n    \n    return { data, error: null };\n  } catch (error) {\n    return { data: null, error: handleSupabaseError(error, 'Failed to update data') };\n  }\n};\n\n/**\n * Check if a table exists by trying to query it\n * @param {string} table - Table name\n * @returns {Promise<boolean>}\n */\nexport const tableExists = async (table) => {\n  try {\n    const { error } = await supabase\n      .from(table)\n      .select('*')\n      .limit(1);\n    \n    if (error && error.message.includes('does not exist')) {\n      return false;\n    }\n    \n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nexport default {\n  handleSupabaseError,\n  getUserSafely,\n  signInWithRetry,\n  createRealtimeSubscription,\n  queryTable,\n  insertIntoTable,\n  updateInTable,\n  tableExists\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}