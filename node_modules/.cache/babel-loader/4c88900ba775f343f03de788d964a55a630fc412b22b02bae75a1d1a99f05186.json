{"ast":null,"code":"import { startInactiveSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, timestampInSeconds, withActiveSpan, spanToJSON } from '@sentry/core';\nimport * as React from 'react';\nimport { REACT_MOUNT_OP, REACT_UPDATE_OP, REACT_RENDER_OP } from './constants.js';\nimport { hoistNonReactStatics } from './hoist-non-react-statics.js';\nconst UNKNOWN_COMPONENT = 'unknown';\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n\n  constructor(props) {\n    super(props);\n    const {\n      name,\n      disabled = false\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n    this._mountSpan = startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n        'ui.component_name': name\n      }\n    });\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  componentDidMount() {\n    if (this._mountSpan) {\n      this._mountSpan.end();\n    }\n  }\n  shouldComponentUpdate(_ref) {\n    let {\n      updateProps,\n      includeUpdates = true\n    } = _ref;\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props have changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potentially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = withActiveSpan(this._mountSpan, () => {\n          return startInactiveSpan({\n            name: `<${this.props.name}>`,\n            onlyIfParent: true,\n            op: REACT_UPDATE_OP,\n            startTime: now,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n              'ui.component_name': this.props.name,\n              'ui.react.changed_props': changedProps\n            }\n          });\n        });\n      }\n    }\n    return true;\n  }\n  componentDidUpdate() {\n    if (this._updateSpan) {\n      this._updateSpan.end();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  componentWillUnmount() {\n    const endTimestamp = timestampInSeconds();\n    const {\n      name,\n      includeRender = true\n    } = this.props;\n    if (this._mountSpan && includeRender) {\n      const startTime = spanToJSON(this._mountSpan).timestamp;\n      withActiveSpan(this._mountSpan, () => {\n        const renderSpan = startInactiveSpan({\n          onlyIfParent: true,\n          name: `<${name}>`,\n          op: REACT_RENDER_OP,\n          startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n            'ui.component_name': name\n          }\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      });\n    }\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\n// React.Component default props are defined as static property on the class\nObject.assign(Profiler, {\n  defaultProps: {\n    disabled: false,\n    includeRender: true,\n    includeUpdates: true\n  }\n});\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withProfiler(WrappedComponent,\n// We do not want to have `updateProps` given in options, it is instead filled through the HOC.\noptions) {\n  const componentDisplayName = options?.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(Profiler, {\n    ...options,\n    name: componentDisplayName,\n    updateProps: props\n  }, React.createElement(WrappedComponent, {\n    ...props\n  }));\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    disabled: false,\n    hasRenderSpan: true\n  };\n  const [mountSpan] = React.useState(() => {\n    if (options?.disabled) {\n      return undefined;\n    }\n    return startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n        'ui.component_name': name\n      }\n    });\n  });\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.end();\n    }\n    return () => {\n      if (mountSpan && options.hasRenderSpan) {\n        const startTime = spanToJSON(mountSpan).timestamp;\n        const endTimestamp = timestampInSeconds();\n        const renderSpan = startInactiveSpan({\n          name: `<${name}>`,\n          onlyIfParent: true,\n          op: REACT_RENDER_OP,\n          startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n            'ui.component_name': name\n          }\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\nexport { Profiler, UNKNOWN_COMPONENT, useProfiler, withProfiler };","map":{"version":3,"names":["UNKNOWN_COMPONENT","Profiler","React","Component","constructor","props","name","disabled","_mountSpan","startInactiveSpan","onlyIfParent","op","REACT_MOUNT_OP","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","componentDidMount","end","shouldComponentUpdate","_ref","updateProps","includeUpdates","changedProps","Object","keys","filter","k","length","now","timestampInSeconds","_updateSpan","withActiveSpan","REACT_UPDATE_OP","startTime","componentDidUpdate","undefined","componentWillUnmount","endTimestamp","includeRender","spanToJSON","timestamp","renderSpan","REACT_RENDER_OP","render","children","assign","defaultProps","withProfiler","WrappedComponent","options","componentDisplayName","displayName","Wrapped","createElement","hoistNonReactStatics","useProfiler","arguments","hasRenderSpan","mountSpan","useState","useEffect"],"sources":["/workspace/node_modules/@sentry/react/src/profiler.tsx"],"sourcesContent":["import { startInactiveSpan } from '@sentry/browser';\nimport type { Span } from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, spanToJSON, timestampInSeconds, withActiveSpan } from '@sentry/core';\nimport * as React from 'react';\nimport { REACT_MOUNT_OP, REACT_RENDER_OP, REACT_UPDATE_OP } from './constants';\nimport { hoistNonReactStatics } from './hoist-non-react-statics';\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type ProfilerProps = {\n  // The name of the component being profiled.\n  name: string;\n  // If the Profiler is disabled. False by default. This is useful if you want to disable profilers\n  // in certain environments.\n  disabled?: boolean;\n  // If time component is on page should be displayed as spans. True by default.\n  includeRender?: boolean;\n  // If component updates should be displayed as spans. True by default.\n  includeUpdates?: boolean;\n  // Component that is being profiled.\n  children?: React.ReactNode;\n  // props given to component being profiled.\n  updateProps: { [key: string]: unknown };\n};\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component<ProfilerProps> {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n  protected _mountSpan: Span | undefined;\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n  protected _updateSpan: Span | undefined;\n\n  public constructor(props: ProfilerProps) {\n    super(props);\n    const { name, disabled = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    this._mountSpan = startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n        'ui.component_name': name,\n      },\n    });\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  public componentDidMount(): void {\n    if (this._mountSpan) {\n      this._mountSpan.end();\n    }\n  }\n\n  public shouldComponentUpdate({ updateProps, includeUpdates = true }: ProfilerProps): boolean {\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props have changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potentially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = withActiveSpan(this._mountSpan, () => {\n          return startInactiveSpan({\n            name: `<${this.props.name}>`,\n            onlyIfParent: true,\n            op: REACT_UPDATE_OP,\n            startTime: now,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n              'ui.component_name': this.props.name,\n              'ui.react.changed_props': changedProps,\n            },\n          });\n        });\n      }\n    }\n\n    return true;\n  }\n\n  public componentDidUpdate(): void {\n    if (this._updateSpan) {\n      this._updateSpan.end();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  public componentWillUnmount(): void {\n    const endTimestamp = timestampInSeconds();\n    const { name, includeRender = true } = this.props;\n\n    if (this._mountSpan && includeRender) {\n      const startTime = spanToJSON(this._mountSpan).timestamp;\n      withActiveSpan(this._mountSpan, () => {\n        const renderSpan = startInactiveSpan({\n          onlyIfParent: true,\n          name: `<${name}>`,\n          op: REACT_RENDER_OP,\n          startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n            'ui.component_name': name,\n          },\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      });\n    }\n  }\n\n  public render(): React.ReactNode {\n    return this.props.children;\n  }\n}\n\n// React.Component default props are defined as static property on the class\nObject.assign(Profiler, {\n  defaultProps: {\n    disabled: false,\n    includeRender: true,\n    includeUpdates: true,\n  },\n});\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withProfiler<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  // We do not want to have `updateProps` given in options, it is instead filled through the HOC.\n  options?: Pick<Partial<ProfilerProps>, Exclude<keyof ProfilerProps, 'updateProps' | 'children'>>,\n): React.FC<P> {\n  const componentDisplayName =\n    options?.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <Profiler {...options} name={componentDisplayName} updateProps={props}>\n      <WrappedComponent {...props} />\n    </Profiler>\n  );\n\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(\n  name: string,\n  options: { disabled?: boolean; hasRenderSpan?: boolean } = {\n    disabled: false,\n    hasRenderSpan: true,\n  },\n): void {\n  const [mountSpan] = React.useState(() => {\n    if (options?.disabled) {\n      return undefined;\n    }\n\n    return startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n        'ui.component_name': name,\n      },\n    });\n  });\n\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.end();\n    }\n\n    return (): void => {\n      if (mountSpan && options.hasRenderSpan) {\n        const startTime = spanToJSON(mountSpan).timestamp;\n        const endTimestamp = timestampInSeconds();\n\n        const renderSpan = startInactiveSpan({\n          name: `<${name}>`,\n          onlyIfParent: true,\n          op: REACT_RENDER_OP,\n          startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.react.profiler',\n            'ui.component_name': name,\n          },\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n\nexport { Profiler, useProfiler, withProfiler };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}