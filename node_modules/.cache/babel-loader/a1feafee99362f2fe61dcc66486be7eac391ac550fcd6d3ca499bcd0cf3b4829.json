{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { debug } from './debug-logger.js';\nimport { isString } from './is.js';\nconst SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nconst MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n// Very liberal definition of what any incoming header might look like\nbaggageHeader) {\n  const baggageObject = parseBaggageHeader(baggageHeader);\n  if (!baggageObject) {\n    return undefined;\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, _ref) => {\n    let [key, value] = _ref;\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n// this also takes undefined for convenience and bundle size in other places\ndynamicSamplingContext) {\n  if (!dynamicSamplingContext) {\n    return undefined;\n  }\n\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce((acc, _ref2) => {\n    let [dscKey, dscValue] = _ref2;\n    if (dscValue) {\n      acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n    }\n    return acc;\n  }, {});\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Take a baggage header and parse it into an object.\n */\nfunction parseBaggageHeader(baggageHeader) {\n  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    return baggageHeader.reduce((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      Object.entries(currBaggageObject).forEach(_ref3 => {\n        let [key, value] = _ref3;\n        acc[key] = value;\n      });\n      return acc;\n    }, {});\n  }\n  return baggageHeaderToObject(baggageHeader);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader.split(',').map(baggageEntry => baggageEntry.split('=').map(keyOrValue => {\n    try {\n      return decodeURIComponent(keyOrValue.trim());\n    } catch {\n      // We ignore errors here, e.g. if the value cannot be URL decoded.\n      // This will then be skipped in the next step\n      return;\n    }\n  })).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n  return Object.entries(object).reduce((baggageHeader, _ref5, currentIndex) => {\n    let [objectKey, objectValue] = _ref5;\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      DEBUG_BUILD && debug.warn(`Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`);\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\nexport { MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader, objectToBaggageHeader, parseBaggageHeader };","map":{"version":3,"names":["SENTRY_BAGGAGE_KEY_PREFIX","SENTRY_BAGGAGE_KEY_PREFIX_REGEX","MAX_BAGGAGE_STRING_LENGTH","baggageHeaderToDynamicSamplingContext","baggageHeader","baggageObject","parseBaggageHeader","undefined","dynamicSamplingContext","Object","entries","reduce","acc","_ref","key","value","match","nonPrefixedKey","slice","length","keys","dynamicSamplingContextToSentryBaggageHeader","sentryPrefixedDSC","_ref2","dscKey","dscValue","objectToBaggageHeader","isString","Array","isArray","curr","currBaggageObject","baggageHeaderToObject","forEach","_ref3","split","map","baggageEntry","keyOrValue","decodeURIComponent","trim","_ref4","object","_ref5","currentIndex","objectKey","objectValue","encodeURIComponent","newBaggageHeader","DEBUG_BUILD","debug","warn"],"sources":["/workspace/node_modules/@sentry/core/src/utils/baggage.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport { debug } from './debug-logger';\nimport { isString } from './is';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nexport const MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nexport function baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader: string | string[] | number | null | undefined | boolean,\n): Partial<DynamicSamplingContext> | undefined {\n  const baggageObject = parseBaggageHeader(baggageHeader);\n\n  if (!baggageObject) {\n    return undefined;\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce<Record<string, string>>((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext as Partial<DynamicSamplingContext>;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nexport function dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext?: Partial<DynamicSamplingContext>,\n): string | undefined {\n  if (!dynamicSamplingContext) {\n    return undefined;\n  }\n\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce<Record<string, string>>(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Take a baggage header and parse it into an object.\n */\nexport function parseBaggageHeader(\n  baggageHeader: string | string[] | number | null | undefined | boolean,\n): Record<string, string> | undefined {\n  if (!baggageHeader || (!isString(baggageHeader) && !Array.isArray(baggageHeader))) {\n    return undefined;\n  }\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    return baggageHeader.reduce<Record<string, string>>((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      Object.entries(currBaggageObject).forEach(([key, value]) => {\n        acc[key] = value;\n      });\n      return acc;\n    }, {});\n  }\n\n  return baggageHeaderToObject(baggageHeader);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader: string): Record<string, string> {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry =>\n      baggageEntry.split('=').map(keyOrValue => {\n        try {\n          return decodeURIComponent(keyOrValue.trim());\n        } catch {\n          // We ignore errors here, e.g. if the value cannot be URL decoded.\n          // This will then be skipped in the next step\n          return;\n        }\n      }),\n    )\n    .reduce<Record<string, string>>((acc, [key, value]) => {\n      if (key && value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nexport function objectToBaggageHeader(object: Record<string, string>): string | undefined {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      DEBUG_BUILD &&\n        debug.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}