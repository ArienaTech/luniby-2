{"ast":null,"code":"import { browserTracingIntegration, WINDOW, startBrowserTracingPageLoadSpan, startBrowserTracingNavigationSpan } from '@sentry/browser';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from '@sentry/core';\n\n/**\n * A custom browser tracing integration for TanStack Router.\n *\n * The minimum compatible version of `@tanstack/react-router` is `1.64.0`.\n *\n * @param router A TanStack Router `Router` instance that should be used for routing instrumentation.\n * @param options Sentry browser tracing configuration.\n */\nfunction tanstackRouterBrowserTracingIntegration(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrouter) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const castRouterInstance = router;\n  const browserTracingIntegrationInstance = browserTracingIntegration({\n    ...options,\n    instrumentNavigation: false,\n    instrumentPageLoad: false\n  });\n  const {\n    instrumentPageLoad = true,\n    instrumentNavigation = true\n  } = options;\n  return {\n    ...browserTracingIntegrationInstance,\n    afterAllSetup(client) {\n      browserTracingIntegrationInstance.afterAllSetup(client);\n      const initialWindowLocation = WINDOW.location;\n      if (instrumentPageLoad && initialWindowLocation) {\n        const matchedRoutes = castRouterInstance.matchRoutes(initialWindowLocation.pathname, castRouterInstance.options.parseSearch(initialWindowLocation.search), {\n          preload: false,\n          throwOnError: false\n        });\n        const lastMatch = matchedRoutes[matchedRoutes.length - 1];\n        startBrowserTracingPageLoadSpan(client, {\n          name: lastMatch ? lastMatch.routeId : initialWindowLocation.pathname,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.tanstack_router',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: lastMatch ? 'route' : 'url',\n            ...routeMatchToParamSpanAttributes(lastMatch)\n          }\n        });\n      }\n      if (instrumentNavigation) {\n        // The onBeforeNavigate hook is called at the very beginning of a navigation and is only called once per navigation, even when the user is redirected\n        castRouterInstance.subscribe('onBeforeNavigate', onBeforeNavigateArgs => {\n          // onBeforeNavigate is called during pageloads. We can avoid creating navigation spans by comparing the states of the to and from arguments.\n          if (onBeforeNavigateArgs.toLocation.state === onBeforeNavigateArgs.fromLocation?.state) {\n            return;\n          }\n          const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(onBeforeNavigateArgs.toLocation.pathname, onBeforeNavigateArgs.toLocation.search, {\n            preload: false,\n            throwOnError: false\n          });\n          const onBeforeNavigateLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n          const navigationLocation = WINDOW.location;\n          const navigationSpan = startBrowserTracingNavigationSpan(client, {\n            name: onBeforeNavigateLastMatch ? onBeforeNavigateLastMatch.routeId : navigationLocation.pathname,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.tanstack_router',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: onBeforeNavigateLastMatch ? 'route' : 'url'\n            }\n          });\n\n          // In case the user is redirected during navigation we want to update the span with the right value.\n          const unsubscribeOnResolved = castRouterInstance.subscribe('onResolved', onResolvedArgs => {\n            unsubscribeOnResolved();\n            if (navigationSpan) {\n              const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(onResolvedArgs.toLocation.pathname, onResolvedArgs.toLocation.search, {\n                preload: false,\n                throwOnError: false\n              });\n              const onResolvedLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n              if (onResolvedLastMatch) {\n                navigationSpan.updateName(onResolvedLastMatch.routeId);\n                navigationSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');\n                navigationSpan.setAttributes(routeMatchToParamSpanAttributes(onResolvedLastMatch));\n              }\n            }\n          });\n        });\n      }\n    }\n  };\n}\nfunction routeMatchToParamSpanAttributes(match) {\n  if (!match) {\n    return {};\n  }\n  const paramAttributes = {};\n  Object.entries(match.params).forEach(_ref => {\n    let [key, value] = _ref;\n    paramAttributes[`url.path.params.${key}`] = value; // todo(v10): remove attribute which does not adhere to Sentry's semantic convention\n    paramAttributes[`url.path.parameter.${key}`] = value;\n    paramAttributes[`params.${key}`] = value; // params.[key] is an alias\n  });\n  return paramAttributes;\n}\nexport { tanstackRouterBrowserTracingIntegration };","map":{"version":3,"names":["tanstackRouterBrowserTracingIntegration","router","options","arguments","length","undefined","castRouterInstance","browserTracingIntegrationInstance","browserTracingIntegration","instrumentNavigation","instrumentPageLoad","afterAllSetup","client","initialWindowLocation","WINDOW","location","matchedRoutes","matchRoutes","pathname","parseSearch","search","preload","throwOnError","lastMatch","startBrowserTracingPageLoadSpan","name","routeId","attributes","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","routeMatchToParamSpanAttributes","subscribe","onBeforeNavigateArgs","toLocation","state","fromLocation","onResolvedMatchedRoutes","onBeforeNavigateLastMatch","navigationLocation","navigationSpan","startBrowserTracingNavigationSpan","unsubscribeOnResolved","onResolvedArgs","onResolvedLastMatch","updateName","setAttribute","setAttributes","match","paramAttributes","Object","entries","params","forEach","_ref","key","value"],"sources":["/workspace/node_modules/@sentry/react/src/tanstackrouter.ts"],"sourcesContent":["import {\n  browserTracingIntegration as originalBrowserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n  WINDOW,\n} from '@sentry/browser';\nimport type { Integration } from '@sentry/core';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '@sentry/core';\nimport type { VendoredTanstackRouter, VendoredTanstackRouterRouteMatch } from './vendor/tanstackrouter-types';\n\n/**\n * A custom browser tracing integration for TanStack Router.\n *\n * The minimum compatible version of `@tanstack/react-router` is `1.64.0`.\n *\n * @param router A TanStack Router `Router` instance that should be used for routing instrumentation.\n * @param options Sentry browser tracing configuration.\n */\nexport function tanstackRouterBrowserTracingIntegration(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  router: any, // This is `any` because we don't want any type mismatches if TanStack Router changes their types\n  options: Parameters<typeof originalBrowserTracingIntegration>[0] = {},\n): Integration {\n  const castRouterInstance: VendoredTanstackRouter = router;\n\n  const browserTracingIntegrationInstance = originalBrowserTracingIntegration({\n    ...options,\n    instrumentNavigation: false,\n    instrumentPageLoad: false,\n  });\n\n  const { instrumentPageLoad = true, instrumentNavigation = true } = options;\n\n  return {\n    ...browserTracingIntegrationInstance,\n    afterAllSetup(client) {\n      browserTracingIntegrationInstance.afterAllSetup(client);\n\n      const initialWindowLocation = WINDOW.location;\n      if (instrumentPageLoad && initialWindowLocation) {\n        const matchedRoutes = castRouterInstance.matchRoutes(\n          initialWindowLocation.pathname,\n          castRouterInstance.options.parseSearch(initialWindowLocation.search),\n          { preload: false, throwOnError: false },\n        );\n\n        const lastMatch = matchedRoutes[matchedRoutes.length - 1];\n\n        startBrowserTracingPageLoadSpan(client, {\n          name: lastMatch ? lastMatch.routeId : initialWindowLocation.pathname,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.react.tanstack_router',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: lastMatch ? 'route' : 'url',\n            ...routeMatchToParamSpanAttributes(lastMatch),\n          },\n        });\n      }\n\n      if (instrumentNavigation) {\n        // The onBeforeNavigate hook is called at the very beginning of a navigation and is only called once per navigation, even when the user is redirected\n        castRouterInstance.subscribe('onBeforeNavigate', onBeforeNavigateArgs => {\n          // onBeforeNavigate is called during pageloads. We can avoid creating navigation spans by comparing the states of the to and from arguments.\n          if (onBeforeNavigateArgs.toLocation.state === onBeforeNavigateArgs.fromLocation?.state) {\n            return;\n          }\n\n          const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(\n            onBeforeNavigateArgs.toLocation.pathname,\n            onBeforeNavigateArgs.toLocation.search,\n            { preload: false, throwOnError: false },\n          );\n\n          const onBeforeNavigateLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n\n          const navigationLocation = WINDOW.location;\n          const navigationSpan = startBrowserTracingNavigationSpan(client, {\n            name: onBeforeNavigateLastMatch ? onBeforeNavigateLastMatch.routeId : navigationLocation.pathname,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.react.tanstack_router',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: onBeforeNavigateLastMatch ? 'route' : 'url',\n            },\n          });\n\n          // In case the user is redirected during navigation we want to update the span with the right value.\n          const unsubscribeOnResolved = castRouterInstance.subscribe('onResolved', onResolvedArgs => {\n            unsubscribeOnResolved();\n            if (navigationSpan) {\n              const onResolvedMatchedRoutes = castRouterInstance.matchRoutes(\n                onResolvedArgs.toLocation.pathname,\n                onResolvedArgs.toLocation.search,\n                { preload: false, throwOnError: false },\n              );\n\n              const onResolvedLastMatch = onResolvedMatchedRoutes[onResolvedMatchedRoutes.length - 1];\n\n              if (onResolvedLastMatch) {\n                navigationSpan.updateName(onResolvedLastMatch.routeId);\n                navigationSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');\n                navigationSpan.setAttributes(routeMatchToParamSpanAttributes(onResolvedLastMatch));\n              }\n            }\n          });\n        });\n      }\n    },\n  };\n}\n\nfunction routeMatchToParamSpanAttributes(match: VendoredTanstackRouterRouteMatch | undefined): Record<string, string> {\n  if (!match) {\n    return {};\n  }\n\n  const paramAttributes: Record<string, string> = {};\n  Object.entries(match.params).forEach(([key, value]) => {\n    paramAttributes[`url.path.params.${key}`] = value; // todo(v10): remove attribute which does not adhere to Sentry's semantic convention\n    paramAttributes[`url.path.parameter.${key}`] = value;\n    paramAttributes[`params.${key}`] = value; // params.[key] is an alias\n  });\n\n  return paramAttributes;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}