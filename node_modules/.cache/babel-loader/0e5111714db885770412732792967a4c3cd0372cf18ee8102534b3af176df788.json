{"ast":null,"code":"import { OPENAI_OPERATIONS, GEN_AI_RESPONSE_ID_ATTRIBUTE, OPENAI_RESPONSE_ID_ATTRIBUTE, GEN_AI_RESPONSE_MODEL_ATTRIBUTE, OPENAI_RESPONSE_MODEL_ATTRIBUTE, OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE } from '../gen-ai-attributes.js';\nimport { INSTRUMENTED_METHODS } from './constants.js';\n\n/**\n * Maps OpenAI method paths to Sentry operation names\n */\nfunction getOperationName(methodPath) {\n  if (methodPath.includes('chat.completions')) {\n    return OPENAI_OPERATIONS.CHAT;\n  }\n  if (methodPath.includes('responses')) {\n    return OPENAI_OPERATIONS.RESPONSES;\n  }\n  return methodPath.split('.').pop() || 'unknown';\n}\n\n/**\n * Get the span operation for OpenAI methods\n * Following Sentry's convention: \"gen_ai.{operation_name}\"\n */\nfunction getSpanOperation(methodPath) {\n  return `gen_ai.${getOperationName(methodPath)}`;\n}\n\n/**\n * Check if a method path should be instrumented\n */\nfunction shouldInstrument(methodPath) {\n  return INSTRUMENTED_METHODS.includes(methodPath);\n}\n\n/**\n * Build method path from current traversal\n */\nfunction buildMethodPath(currentPath, prop) {\n  return currentPath ? `${currentPath}.${prop}` : prop;\n}\n\n/**\n * Check if response is a Chat Completion object\n */\nfunction isChatCompletionResponse(response) {\n  return response !== null && typeof response === 'object' && 'object' in response && response.object === 'chat.completion';\n}\n\n/**\n * Check if response is a Responses API object\n */\nfunction isResponsesApiResponse(response) {\n  return response !== null && typeof response === 'object' && 'object' in response && response.object === 'response';\n}\n\n/**\n * Check if streaming event is from the Responses API\n */\nfunction isResponsesApiStreamEvent(event) {\n  return event !== null && typeof event === 'object' && 'type' in event && typeof event.type === 'string' && event.type.startsWith('response.');\n}\n\n/**\n * Check if streaming event is a chat completion chunk\n */\nfunction isChatCompletionChunk(event) {\n  return event !== null && typeof event === 'object' && 'object' in event && event.object === 'chat.completion.chunk';\n}\n\n/**\n * Set token usage attributes\n * @param span - The span to add attributes to\n * @param promptTokens - The number of prompt tokens\n * @param completionTokens - The number of completion tokens\n * @param totalTokens - The number of total tokens\n */\nfunction setTokenUsageAttributes(span, promptTokens, completionTokens, totalTokens) {\n  if (promptTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: promptTokens,\n      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens\n    });\n  }\n  if (completionTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: completionTokens,\n      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens\n    });\n  }\n  if (totalTokens !== undefined) {\n    span.setAttributes({\n      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens\n    });\n  }\n}\n\n/**\n * Set common response attributes\n * @param span - The span to add attributes to\n * @param id - The response id\n * @param model - The response model\n * @param timestamp - The response timestamp\n */\nfunction setCommonResponseAttributes(span, id, model, timestamp) {\n  span.setAttributes({\n    [OPENAI_RESPONSE_ID_ATTRIBUTE]: id,\n    [GEN_AI_RESPONSE_ID_ATTRIBUTE]: id\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_MODEL_ATTRIBUTE]: model,\n    [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: model\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(timestamp * 1000).toISOString()\n  });\n}\nexport { buildMethodPath, getOperationName, getSpanOperation, isChatCompletionChunk, isChatCompletionResponse, isResponsesApiResponse, isResponsesApiStreamEvent, setCommonResponseAttributes, setTokenUsageAttributes, shouldInstrument };","map":{"version":3,"names":["getOperationName","methodPath","includes","OPENAI_OPERATIONS","CHAT","RESPONSES","split","pop","getSpanOperation","shouldInstrument","INSTRUMENTED_METHODS","buildMethodPath","currentPath","prop","isChatCompletionResponse","response","object","isResponsesApiResponse","isResponsesApiStreamEvent","event","type","startsWith","isChatCompletionChunk","setTokenUsageAttributes","span","promptTokens","completionTokens","totalTokens","undefined","setAttributes","OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE","GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE","OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE","GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE","GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE","setCommonResponseAttributes","id","model","timestamp","OPENAI_RESPONSE_ID_ATTRIBUTE","GEN_AI_RESPONSE_ID_ATTRIBUTE","OPENAI_RESPONSE_MODEL_ATTRIBUTE","GEN_AI_RESPONSE_MODEL_ATTRIBUTE","OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE","Date","toISOString"],"sources":["/workspace/node_modules/@sentry/core/src/utils/openai/utils.ts"],"sourcesContent":["import type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n  OPENAI_OPERATIONS,\n  OPENAI_RESPONSE_ID_ATTRIBUTE,\n  OPENAI_RESPONSE_MODEL_ATTRIBUTE,\n  OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE,\n  OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE,\n  OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE,\n} from '../gen-ai-attributes';\nimport { INSTRUMENTED_METHODS } from './constants';\nimport type {\n  ChatCompletionChunk,\n  InstrumentedMethod,\n  OpenAiChatCompletionObject,\n  OpenAIResponseObject,\n  ResponseStreamingEvent,\n} from './types';\n\n/**\n * Maps OpenAI method paths to Sentry operation names\n */\nexport function getOperationName(methodPath: string): string {\n  if (methodPath.includes('chat.completions')) {\n    return OPENAI_OPERATIONS.CHAT;\n  }\n  if (methodPath.includes('responses')) {\n    return OPENAI_OPERATIONS.RESPONSES;\n  }\n  return methodPath.split('.').pop() || 'unknown';\n}\n\n/**\n * Get the span operation for OpenAI methods\n * Following Sentry's convention: \"gen_ai.{operation_name}\"\n */\nexport function getSpanOperation(methodPath: string): string {\n  return `gen_ai.${getOperationName(methodPath)}`;\n}\n\n/**\n * Check if a method path should be instrumented\n */\nexport function shouldInstrument(methodPath: string): methodPath is InstrumentedMethod {\n  return INSTRUMENTED_METHODS.includes(methodPath as InstrumentedMethod);\n}\n\n/**\n * Build method path from current traversal\n */\nexport function buildMethodPath(currentPath: string, prop: string): string {\n  return currentPath ? `${currentPath}.${prop}` : prop;\n}\n\n/**\n * Check if response is a Chat Completion object\n */\nexport function isChatCompletionResponse(response: unknown): response is OpenAiChatCompletionObject {\n  return (\n    response !== null &&\n    typeof response === 'object' &&\n    'object' in response &&\n    (response as Record<string, unknown>).object === 'chat.completion'\n  );\n}\n\n/**\n * Check if response is a Responses API object\n */\nexport function isResponsesApiResponse(response: unknown): response is OpenAIResponseObject {\n  return (\n    response !== null &&\n    typeof response === 'object' &&\n    'object' in response &&\n    (response as Record<string, unknown>).object === 'response'\n  );\n}\n\n/**\n * Check if streaming event is from the Responses API\n */\nexport function isResponsesApiStreamEvent(event: unknown): event is ResponseStreamingEvent {\n  return (\n    event !== null &&\n    typeof event === 'object' &&\n    'type' in event &&\n    typeof (event as Record<string, unknown>).type === 'string' &&\n    ((event as Record<string, unknown>).type as string).startsWith('response.')\n  );\n}\n\n/**\n * Check if streaming event is a chat completion chunk\n */\nexport function isChatCompletionChunk(event: unknown): event is ChatCompletionChunk {\n  return (\n    event !== null &&\n    typeof event === 'object' &&\n    'object' in event &&\n    (event as Record<string, unknown>).object === 'chat.completion.chunk'\n  );\n}\n\n/**\n * Set token usage attributes\n * @param span - The span to add attributes to\n * @param promptTokens - The number of prompt tokens\n * @param completionTokens - The number of completion tokens\n * @param totalTokens - The number of total tokens\n */\nexport function setTokenUsageAttributes(\n  span: Span,\n  promptTokens?: number,\n  completionTokens?: number,\n  totalTokens?: number,\n): void {\n  if (promptTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: promptTokens,\n      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens,\n    });\n  }\n  if (completionTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: completionTokens,\n      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens,\n    });\n  }\n  if (totalTokens !== undefined) {\n    span.setAttributes({\n      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens,\n    });\n  }\n}\n\n/**\n * Set common response attributes\n * @param span - The span to add attributes to\n * @param id - The response id\n * @param model - The response model\n * @param timestamp - The response timestamp\n */\nexport function setCommonResponseAttributes(span: Span, id: string, model: string, timestamp: number): void {\n  span.setAttributes({\n    [OPENAI_RESPONSE_ID_ATTRIBUTE]: id,\n    [GEN_AI_RESPONSE_ID_ATTRIBUTE]: id,\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_MODEL_ATTRIBUTE]: model,\n    [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: model,\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(timestamp * 1000).toISOString(),\n  });\n}\n"],"mappings":";;;AAuBA;AACA;AACA;AACO,SAASA,gBAAgBA,CAACC,UAAU,EAAkB;EAC3D,IAAIA,UAAU,CAACC,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IAC3C,OAAOC,iBAAiB,CAACC,IAAI;EACjC;EACE,IAAIH,UAAU,CAACC,QAAQ,CAAC,WAAW,CAAC,EAAE;IACpC,OAAOC,iBAAiB,CAACE,SAAS;EACtC;EACE,OAAOJ,UAAU,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAC,IAAK,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACO,SAASC,gBAAgBA,CAACP,UAAU,EAAkB;EAC3D,OAAO,UAAUD,gBAAgB,CAACC,UAAU,CAAC,EAAC;AACA;;AAEA;AACA;AACA;AACA,SAAAQ,iBAAAR,UAAA;EACA,OAAAS,oBAAA,CAAAR,QAAA,CAAAD,UAAA;AACA;;AAEA;AACA;AACA;AACA,SAAAU,gBAAAC,WAAA,EAAAC,IAAA;EACA,OAAAD,WAAA,MAAAA,WAAA,IAAAC,IAAA,KAAAA,IAAA;AACA;;AAEA;AACA;AACA;AACA,SAAAC,yBAAAC,QAAA;EACA,OACAA,QAAA,aACA,OAAAA,QAAA,iBACA,YAAAA,QAAA,IACAA,QAAA,CAAAC,MAAA;AAEA;;AAEA;AACA;AACA;AACA,SAAAC,uBAAAF,QAAA;EACA,OACAA,QAAA,aACA,OAAAA,QAAA,iBACA,YAAAA,QAAA,IACAA,QAAA,CAAAC,MAAA;AAEA;;AAEA;AACA;AACA;AACA,SAAAE,0BAAAC,KAAA;EACA,OACAA,KAAA,aACA,OAAAA,KAAA,iBACA,UAAAA,KAAA,IACA,OAAAA,KAAA,CAAAC,IAAA,iBACAD,KAAA,CAAAC,IAAA,CAAAC,UAAA;AAEA;;AAEA;AACA;AACA;AACA,SAAAC,sBAAAH,KAAA;EACA,OACAA,KAAA,aACA,OAAAA,KAAA,iBACA,YAAAA,KAAA,IACAA,KAAA,CAAAH,MAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAO,wBACAC,IAAA,EACAC,YAAA,EACAC,gBAAA,EACAC,WAAA,EACA;EACA,IAAAF,YAAA,KAAAG,SAAA;IACAJ,IAAA,CAAAK,aAAA;MACA,CAAAC,oCAAA,GAAAL,YAAA;MACA,CAAAM,mCAAA,GAAAN;IACA;EACA;EACA,IAAAC,gBAAA,KAAAE,SAAA;IACAJ,IAAA,CAAAK,aAAA;MACA,CAAAG,wCAAA,GAAAN,gBAAA;MACA,CAAAO,oCAAA,GAAAP;IACA;EACA;EACA,IAAAC,WAAA,KAAAC,SAAA;IACAJ,IAAA,CAAAK,aAAA;MACA,CAAAK,mCAAA,GAAAP;IACA;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAQ,4BAAAX,IAAA,EAAAY,EAAA,EAAAC,KAAA,EAAAC,SAAA;EACAd,IAAA,CAAAK,aAAA;IACA,CAAAU,4BAAA,GAAAH,EAAA;IACA,CAAAI,4BAAA,GAAAJ;EACA;EACAZ,IAAA,CAAAK,aAAA;IACA,CAAAY,+BAAA,GAAAJ,KAAA;IACA,CAAAK,+BAAA,GAAAL;EACA;EACAb,IAAA,CAAAK,aAAA;IACA,CAAAc,mCAAA,OAAAC,IAAA,CAAAN,SAAA,SAAAO,WAAA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}