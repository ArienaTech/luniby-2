{"ast":null,"code":"import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { withScope, getCurrentScope, getClient, getIsolationScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { baggageHeaderToDynamicSamplingContext } from '../utils/baggage.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { parseSampleRate } from '../utils/parseSampleRate.js';\nimport { generateTraceId } from '../utils/propagationContext.js';\nimport { _setSpanForScope, _getSpanForScope } from '../utils/spanOnScope.js';\nimport { spanToJSON, spanTimeInputToSeconds, getRootSpan, addChildSpanToSpan, spanIsSampled } from '../utils/spanUtils.js';\nimport { shouldContinueTrace, propagationContextFromHeaders } from '../utils/tracing.js';\nimport { getDynamicSamplingContextFromSpan, freezeDscOnSpan } from './dynamicSamplingContext.js';\nimport { logSpanStart } from './logSpans.js';\nimport { sampleSpan } from './sampling.js';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan.js';\nimport { SentrySpan } from './sentrySpan.js';\nimport { SPAN_STATUS_ERROR } from './spanstatus.js';\nimport { setCapturedScopesOnSpan } from './utils.js';\n\n/* eslint-disable max-lines */\n\nconst SUPPRESS_TRACING_KEY = '__SENTRY_SUPPRESS_TRACING__';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(options, callback);\n  }\n  const spanArguments = parseSentrySpanArguments(options);\n  const {\n    forceTransaction,\n    parentSpan: customParentSpan,\n    scope: customScope\n  } = options;\n\n  // We still need to fork a potentially passed scope, as we set the active span on it\n  // and we need to ensure that it is cleaned up properly once the span ends.\n  const customForkedScope = customScope?.clone();\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope, customParentSpan);\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan() : createChildOrRootSpan({\n        parentSpan,\n        spanArguments,\n        forceTransaction,\n        scope\n      });\n      _setSpanForScope(scope, activeSpan);\n      return handleCallbackErrors(() => callback(activeSpan), () => {\n        // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n        const {\n          status\n        } = spanToJSON(activeSpan);\n        if (activeSpan.isRecording() && (!status || status === 'ok')) {\n          activeSpan.setStatus({\n            code: SPAN_STATUS_ERROR,\n            message: 'internal_error'\n          });\n        }\n      }, () => {\n        activeSpan.end();\n      });\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. Use `span.end()` to end the span.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(options, callback) {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(options, callback);\n  }\n  const spanArguments = parseSentrySpanArguments(options);\n  const {\n    forceTransaction,\n    parentSpan: customParentSpan,\n    scope: customScope\n  } = options;\n  const customForkedScope = customScope?.clone();\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper(customParentSpan);\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope, customParentSpan);\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan() : createChildOrRootSpan({\n        parentSpan,\n        spanArguments,\n        forceTransaction,\n        scope\n      });\n      _setSpanForScope(scope, activeSpan);\n      return handleCallbackErrors(\n      // We pass the `finish` function to the callback, so the user can finish the span manually\n      // this is mainly here for historic purposes because previously, we instructed users to call\n      // `finish` instead of `span.end()` to also clean up the scope. Nowadays, calling `span.end()`\n      // or `finish` has the same effect and we simply leave it here to avoid breaking user code.\n      () => callback(activeSpan, () => activeSpan.end()), () => {\n        // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n        const {\n          status\n        } = spanToJSON(activeSpan);\n        if (activeSpan.isRecording() && (!status || status === 'ok')) {\n          activeSpan.setStatus({\n            code: SPAN_STATUS_ERROR,\n            message: 'internal_error'\n          });\n        }\n      });\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(options);\n  }\n  const spanArguments = parseSentrySpanArguments(options);\n  const {\n    forceTransaction,\n    parentSpan: customParentSpan\n  } = options;\n\n  // If `options.scope` is defined, we use this as as a wrapper,\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = options.scope ? callback => withScope(options.scope, callback) : customParentSpan !== undefined ? callback => withActiveSpan(customParentSpan, callback) : callback => callback();\n  return wrapper(() => {\n    const scope = getCurrentScope();\n    const parentSpan = getParentSpan(scope, customParentSpan);\n    const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n    if (shouldSkipSpan) {\n      return new SentryNonRecordingSpan();\n    }\n    return createChildOrRootSpan({\n      parentSpan,\n      spanArguments,\n      forceTransaction,\n      scope\n    });\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nconst continueTrace = (options, callback) => {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.continueTrace) {\n    return acs.continueTrace(options, callback);\n  }\n  const {\n    sentryTrace,\n    baggage\n  } = options;\n  const client = getClient();\n  const incomingDsc = baggageHeaderToDynamicSamplingContext(baggage);\n  if (client && !shouldContinueTrace(client, incomingDsc?.org_id)) {\n    return startNewTrace(callback);\n  }\n  return withScope(scope => {\n    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n  return withScope(scope => {\n    _setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const acs = getAcs();\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n  return withScope(scope => {\n    // Note: We do not wait for the callback to finish before we reset the metadata\n    // the reason for this is that otherwise, in the browser this can lead to very weird behavior\n    // as there is only a single top scope, if the callback takes longer to finish,\n    // other, unrelated spans may also be suppressed, which we do not want\n    // so instead, we only suppress tracing synchronoysly in the browser\n    scope.setSDKProcessingMetadata({\n      [SUPPRESS_TRACING_KEY]: true\n    });\n    const res = callback();\n    scope.setSDKProcessingMetadata({\n      [SUPPRESS_TRACING_KEY]: undefined\n    });\n    return res;\n  });\n}\n\n/**\n * Starts a new trace for the duration of the provided callback. Spans started within the\n * callback will be part of the new trace instead of a potentially previously started trace.\n *\n * Important: Only use this function if you want to override the default trace lifetime and\n * propagation mechanism of the SDK for the duration and scope of the provided callback.\n * The newly created trace will also be the root of a new distributed trace, for example if\n * you make http requests within the callback.\n * This function might be useful if the operation you want to instrument should not be part\n * of a potentially ongoing trace.\n *\n * Default behavior:\n * - Server-side: A new trace is started for each incoming request.\n * - Browser: A new trace is started for each page our route. Navigating to a new route\n *            or page will automatically create a new trace.\n */\nfunction startNewTrace(callback) {\n  return withScope(scope => {\n    scope.setPropagationContext({\n      traceId: generateTraceId(),\n      sampleRand: Math.random()\n    });\n    DEBUG_BUILD && debug.log(`Starting a new trace with id ${scope.getPropagationContext().traceId}`);\n    return withActiveSpan(null, callback);\n  });\n}\nfunction createChildOrRootSpan(_ref) {\n  let {\n    parentSpan,\n    spanArguments,\n    forceTransaction,\n    scope\n  } = _ref;\n  if (!hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    // If this is a root span, we ensure to freeze a DSC\n    // So we can have at least partial data here\n    if (forceTransaction || !parentSpan) {\n      const dsc = {\n        sampled: 'false',\n        sample_rate: '0',\n        transaction: spanArguments.name,\n        ...getDynamicSamplingContextFromSpan(span)\n      };\n      freezeDscOnSpan(span, dsc);\n    }\n    return span;\n  }\n  const isolationScope = getIsolationScope();\n  let span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanArguments);\n    addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const {\n      traceId,\n      spanId: parentSpanId\n    } = parentSpan.spanContext();\n    const parentSampled = spanIsSampled(parentSpan);\n    span = _startRootSpan({\n      traceId,\n      parentSpanId,\n      ...spanArguments\n    }, scope, parentSampled);\n    freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n    span = _startRootSpan({\n      traceId,\n      parentSpanId,\n      ...spanArguments\n    }, scope, parentSampled);\n    if (dsc) {\n      freezeDscOnSpan(span, dsc);\n    }\n  }\n  logSpanStart(span);\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n */\nfunction parseSentrySpanArguments(options) {\n  const exp = options.experimental || {};\n  const initialCtx = {\n    isStandalone: exp.standalone,\n    ...options\n  };\n  if (options.startTime) {\n    const ctx = {\n      ...initialCtx\n    };\n    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n  return initialCtx;\n}\nfunction getAcs() {\n  const carrier = getMainCarrier();\n  return getAsyncContextStrategy(carrier);\n}\nfunction _startRootSpan(spanArguments, scope, parentSampled) {\n  const client = getClient();\n  const options = client?.getOptions() || {};\n  const {\n    name = ''\n  } = spanArguments;\n  const mutableSpanSamplingData = {\n    spanAttributes: {\n      ...spanArguments.attributes\n    },\n    spanName: name,\n    parentSampled\n  };\n\n  // we don't care about the decision for the moment; this is just a placeholder\n  client?.emit('beforeSampling', mutableSpanSamplingData, {\n    decision: false\n  });\n\n  // If hook consumers override the parentSampled flag, we will use that value instead of the actual one\n  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;\n  const finalAttributes = mutableSpanSamplingData.spanAttributes;\n  const currentPropagationContext = scope.getPropagationContext();\n  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(options, {\n    name,\n    parentSampled: finalParentSampled,\n    attributes: finalAttributes,\n    parentSampleRate: parseSampleRate(currentPropagationContext.dsc?.sample_rate)\n  }, currentPropagationContext.sampleRand);\n  const rootSpan = new SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,\n      ...finalAttributes\n    },\n    sampled\n  });\n  if (!sampled && client) {\n    DEBUG_BUILD && debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n    client.recordDroppedEvent('sample_rate', 'transaction');\n  }\n  if (client) {\n    client.emit('spanStart', rootSpan);\n  }\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan, scope, spanArguments) {\n  const {\n    spanId,\n    traceId\n  } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);\n  const childSpan = sampled ? new SentrySpan({\n    ...spanArguments,\n    parentSpanId: spanId,\n    traceId,\n    sampled\n  }) : new SentryNonRecordingSpan({\n    traceId\n  });\n  addChildSpanToSpan(parentSpan, childSpan);\n  const client = getClient();\n  if (client) {\n    client.emit('spanStart', childSpan);\n    // If it has an endTimestamp, it's already ended\n    if (spanArguments.endTimestamp) {\n      client.emit('spanEnd', childSpan);\n    }\n  }\n  return childSpan;\n}\nfunction getParentSpan(scope, customParentSpan) {\n  // always use the passed in span directly\n  if (customParentSpan) {\n    return customParentSpan;\n  }\n\n  // This is different from `undefined` as it means the user explicitly wants no parent span\n  if (customParentSpan === null) {\n    return undefined;\n  }\n  const span = _getSpanForScope(scope);\n  if (!span) {\n    return undefined;\n  }\n  const client = getClient();\n  const options = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return getRootSpan(span);\n  }\n  return span;\n}\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined ? callback => {\n    return withActiveSpan(parentSpan, callback);\n  } : callback => callback();\n}\nexport { continueTrace, startInactiveSpan, startNewTrace, startSpan, startSpanManual, suppressTracing, withActiveSpan };","map":{"version":3,"names":["SUPPRESS_TRACING_KEY","startSpan","options","callback","acs","getAcs","spanArguments","parseSentrySpanArguments","forceTransaction","parentSpan","customParentSpan","scope","customScope","customForkedScope","clone","withScope","wrapper","getActiveSpanWrapper","getCurrentScope","getParentSpan","shouldSkipSpan","onlyIfParent","activeSpan","SentryNonRecordingSpan","createChildOrRootSpan","_setSpanForScope","handleCallbackErrors","status","spanToJSON","isRecording","setStatus","code","SPAN_STATUS_ERROR","message","end","startSpanManual","startInactiveSpan","undefined","withActiveSpan","continueTrace","carrier","getMainCarrier","getAsyncContextStrategy","sentryTrace","baggage","client","getClient","incomingDsc","baggageHeaderToDynamicSamplingContext","shouldContinueTrace","org_id","startNewTrace","propagationContext","propagationContextFromHeaders","setPropagationContext","span","suppressTracing","setSDKProcessingMetadata","res","traceId","generateTraceId","sampleRand","Math","random","DEBUG_BUILD","debug","log","getPropagationContext","_ref","hasSpansEnabled","dsc","sampled","sample_rate","transaction","name","getDynamicSamplingContextFromSpan","freezeDscOnSpan","isolationScope","getIsolationScope","_startChildSpan","addChildSpanToSpan","spanId","parentSpanId","spanContext","parentSampled","spanIsSampled","_startRootSpan","logSpanStart","setCapturedScopesOnSpan","exp","experimental","initialCtx","isStandalone","standalone","startTime","ctx","startTimestamp","spanTimeInputToSeconds","getOptions","mutableSpanSamplingData","spanAttributes","attributes","spanName","emit","decision","finalParentSampled","finalAttributes","currentPropagationContext","sampleRate","localSampleRateWasApplied","getScopeData","sdkProcessingMetadata","sampleSpan","parentSampleRate","parseSampleRate","rootSpan","SentrySpan","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","recordDroppedEvent","childSpan","endTimestamp","_getSpanForScope","parentSpanIsAlwaysRootSpan","getRootSpan"],"sources":["/workspace/node_modules/@sentry/core/src/tracing/trace.ts"],"sourcesContent":["/* eslint-disable max-lines */\n\nimport { getAsyncContextStrategy } from '../asyncContext';\nimport type { AsyncContextStrategy } from '../asyncContext/types';\nimport { getMainCarrier } from '../carrier';\nimport { getClient, getCurrentScope, getIsolationScope, withScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Scope } from '../scope';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport type { ClientOptions } from '../types-hoist/options';\nimport type { SentrySpanArguments, Span, SpanTimeInput } from '../types-hoist/span';\nimport type { StartSpanOptions } from '../types-hoist/startSpanOptions';\nimport { baggageHeaderToDynamicSamplingContext } from '../utils/baggage';\nimport { debug } from '../utils/debug-logger';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled';\nimport { parseSampleRate } from '../utils/parseSampleRate';\nimport { generateTraceId } from '../utils/propagationContext';\nimport { _getSpanForScope, _setSpanForScope } from '../utils/spanOnScope';\nimport { addChildSpanToSpan, getRootSpan, spanIsSampled, spanTimeInputToSeconds, spanToJSON } from '../utils/spanUtils';\nimport { propagationContextFromHeaders, shouldContinueTrace } from '../utils/tracing';\nimport { freezeDscOnSpan, getDynamicSamplingContextFromSpan } from './dynamicSamplingContext';\nimport { logSpanStart } from './logSpans';\nimport { sampleSpan } from './sampling';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan';\nimport { SentrySpan } from './sentrySpan';\nimport { SPAN_STATUS_ERROR } from './spanstatus';\nimport { setCapturedScopesOnSpan } from './utils';\n\nconst SUPPRESS_TRACING_KEY = '__SENTRY_SUPPRESS_TRACING__';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpan<T>(options: StartSpanOptions, callback: (span: Span) => T): T {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  // We still need to fork a potentially passed scope, as we set the active span on it\n  // and we need to ensure that it is cleaned up properly once the span ends.\n  const customForkedScope = customScope?.clone();\n\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope, customParentSpan);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      _setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors(\n        () => callback(activeSpan),\n        () => {\n          // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n          const { status } = spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === 'ok')) {\n            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n          }\n        },\n        () => {\n          activeSpan.end();\n        },\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. Use `span.end()` to end the span.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpanManual<T>(options: StartSpanOptions, callback: (span: Span, finish: () => void) => T): T {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(options, callback);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;\n\n  const customForkedScope = customScope?.clone();\n\n  return withScope(customForkedScope, () => {\n    // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n    const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope, customParentSpan);\n\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      const activeSpan = shouldSkipSpan\n        ? new SentryNonRecordingSpan()\n        : createChildOrRootSpan({\n            parentSpan,\n            spanArguments,\n            forceTransaction,\n            scope,\n          });\n\n      _setSpanForScope(scope, activeSpan);\n\n      return handleCallbackErrors(\n        // We pass the `finish` function to the callback, so the user can finish the span manually\n        // this is mainly here for historic purposes because previously, we instructed users to call\n        // `finish` instead of `span.end()` to also clean up the scope. Nowadays, calling `span.end()`\n        // or `finish` has the same effect and we simply leave it here to avoid breaking user code.\n        () => callback(activeSpan, () => activeSpan.end()),\n        () => {\n          // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n          const { status } = spanToJSON(activeSpan);\n          if (activeSpan.isRecording() && (!status || status === 'ok')) {\n            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startInactiveSpan(options: StartSpanOptions): Span {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(options);\n  }\n\n  const spanArguments = parseSentrySpanArguments(options);\n  const { forceTransaction, parentSpan: customParentSpan } = options;\n\n  // If `options.scope` is defined, we use this as as a wrapper,\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = options.scope\n    ? (callback: () => Span) => withScope(options.scope, callback)\n    : customParentSpan !== undefined\n      ? (callback: () => Span) => withActiveSpan(customParentSpan, callback)\n      : (callback: () => Span) => callback();\n\n  return wrapper(() => {\n    const scope = getCurrentScope();\n    const parentSpan = getParentSpan(scope, customParentSpan);\n\n    const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n\n    if (shouldSkipSpan) {\n      return new SentryNonRecordingSpan();\n    }\n\n    return createChildOrRootSpan({\n      parentSpan,\n      spanArguments,\n      forceTransaction,\n      scope,\n    });\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nexport const continueTrace = <V>(\n  options: {\n    sentryTrace: Parameters<typeof propagationContextFromHeaders>[0];\n    baggage: Parameters<typeof propagationContextFromHeaders>[1];\n  },\n  callback: () => V,\n): V => {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.continueTrace) {\n    return acs.continueTrace(options, callback);\n  }\n\n  const { sentryTrace, baggage } = options;\n\n  const client = getClient();\n  const incomingDsc = baggageHeaderToDynamicSamplingContext(baggage);\n  if (client && !shouldContinueTrace(client, incomingDsc?.org_id)) {\n    return startNewTrace(callback);\n  }\n\n  return withScope(scope => {\n    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span | null, callback: (scope: Scope) => T): T {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n\n  return withScope(scope => {\n    _setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nexport function suppressTracing<T>(callback: () => T): T {\n  const acs = getAcs();\n\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n\n  return withScope(scope => {\n    // Note: We do not wait for the callback to finish before we reset the metadata\n    // the reason for this is that otherwise, in the browser this can lead to very weird behavior\n    // as there is only a single top scope, if the callback takes longer to finish,\n    // other, unrelated spans may also be suppressed, which we do not want\n    // so instead, we only suppress tracing synchronoysly in the browser\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });\n    const res = callback();\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: undefined });\n    return res;\n  });\n}\n\n/**\n * Starts a new trace for the duration of the provided callback. Spans started within the\n * callback will be part of the new trace instead of a potentially previously started trace.\n *\n * Important: Only use this function if you want to override the default trace lifetime and\n * propagation mechanism of the SDK for the duration and scope of the provided callback.\n * The newly created trace will also be the root of a new distributed trace, for example if\n * you make http requests within the callback.\n * This function might be useful if the operation you want to instrument should not be part\n * of a potentially ongoing trace.\n *\n * Default behavior:\n * - Server-side: A new trace is started for each incoming request.\n * - Browser: A new trace is started for each page our route. Navigating to a new route\n *            or page will automatically create a new trace.\n */\nexport function startNewTrace<T>(callback: () => T): T {\n  return withScope(scope => {\n    scope.setPropagationContext({\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    });\n    DEBUG_BUILD && debug.log(`Starting a new trace with id ${scope.getPropagationContext().traceId}`);\n    return withActiveSpan(null, callback);\n  });\n}\n\nfunction createChildOrRootSpan({\n  parentSpan,\n  spanArguments,\n  forceTransaction,\n  scope,\n}: {\n  parentSpan: SentrySpan | undefined;\n  spanArguments: SentrySpanArguments;\n  forceTransaction?: boolean;\n  scope: Scope;\n}): Span {\n  if (!hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    // If this is a root span, we ensure to freeze a DSC\n    // So we can have at least partial data here\n    if (forceTransaction || !parentSpan) {\n      const dsc = {\n        sampled: 'false',\n        sample_rate: '0',\n        transaction: spanArguments.name,\n        ...getDynamicSamplingContextFromSpan(span),\n      } satisfies Partial<DynamicSamplingContext>;\n      freezeDscOnSpan(span, dsc);\n    }\n\n    return span;\n  }\n\n  const isolationScope = getIsolationScope();\n\n  let span: Span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanArguments);\n    addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const parentSampled = spanIsSampled(parentSpan);\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled,\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanArguments,\n      },\n      scope,\n      parentSampled,\n    );\n\n    if (dsc) {\n      freezeDscOnSpan(span, dsc);\n    }\n  }\n\n  logSpanStart(span);\n\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n */\nfunction parseSentrySpanArguments(options: StartSpanOptions): SentrySpanArguments {\n  const exp = options.experimental || {};\n  const initialCtx: SentrySpanArguments = {\n    isStandalone: exp.standalone,\n    ...options,\n  };\n\n  if (options.startTime) {\n    const ctx: SentrySpanArguments & { startTime?: SpanTimeInput } = { ...initialCtx };\n    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return initialCtx;\n}\n\nfunction getAcs(): AsyncContextStrategy {\n  const carrier = getMainCarrier();\n  return getAsyncContextStrategy(carrier);\n}\n\nfunction _startRootSpan(spanArguments: SentrySpanArguments, scope: Scope, parentSampled?: boolean): SentrySpan {\n  const client = getClient();\n  const options: Partial<ClientOptions> = client?.getOptions() || {};\n\n  const { name = '' } = spanArguments;\n\n  const mutableSpanSamplingData = { spanAttributes: { ...spanArguments.attributes }, spanName: name, parentSampled };\n\n  // we don't care about the decision for the moment; this is just a placeholder\n  client?.emit('beforeSampling', mutableSpanSamplingData, { decision: false });\n\n  // If hook consumers override the parentSampled flag, we will use that value instead of the actual one\n  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;\n  const finalAttributes = mutableSpanSamplingData.spanAttributes;\n\n  const currentPropagationContext = scope.getPropagationContext();\n  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[\n    SUPPRESS_TRACING_KEY\n  ]\n    ? [false]\n    : sampleSpan(\n        options,\n        {\n          name,\n          parentSampled: finalParentSampled,\n          attributes: finalAttributes,\n          parentSampleRate: parseSampleRate(currentPropagationContext.dsc?.sample_rate),\n        },\n        currentPropagationContext.sampleRand,\n      );\n\n  const rootSpan = new SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]:\n        sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,\n      ...finalAttributes,\n    },\n    sampled,\n  });\n\n  if (!sampled && client) {\n    DEBUG_BUILD && debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n    client.recordDroppedEvent('sample_rate', 'transaction');\n  }\n\n  if (client) {\n    client.emit('spanStart', rootSpan);\n  }\n\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan: Span, scope: Scope, spanArguments: SentrySpanArguments): Span {\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);\n\n  const childSpan = sampled\n    ? new SentrySpan({\n        ...spanArguments,\n        parentSpanId: spanId,\n        traceId,\n        sampled,\n      })\n    : new SentryNonRecordingSpan({ traceId });\n\n  addChildSpanToSpan(parentSpan, childSpan);\n\n  const client = getClient();\n  if (client) {\n    client.emit('spanStart', childSpan);\n    // If it has an endTimestamp, it's already ended\n    if (spanArguments.endTimestamp) {\n      client.emit('spanEnd', childSpan);\n    }\n  }\n\n  return childSpan;\n}\n\nfunction getParentSpan(scope: Scope, customParentSpan: Span | null | undefined): SentrySpan | undefined {\n  // always use the passed in span directly\n  if (customParentSpan) {\n    return customParentSpan as SentrySpan;\n  }\n\n  // This is different from `undefined` as it means the user explicitly wants no parent span\n  if (customParentSpan === null) {\n    return undefined;\n  }\n\n  const span = _getSpanForScope(scope) as SentrySpan | undefined;\n\n  if (!span) {\n    return undefined;\n  }\n\n  const client = getClient();\n  const options: Partial<ClientOptions> = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return getRootSpan(span) as SentrySpan;\n  }\n\n  return span;\n}\n\nfunction getActiveSpanWrapper<T>(parentSpan: Span | undefined | null): (callback: () => T) => T {\n  return parentSpan !== undefined\n    ? (callback: () => T) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback: () => T) => callback();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}