{"ast":null,"code":"import { getAsyncContextStrategy } from './asyncContext/index.js';\nimport { getMainCarrier, getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\nimport { generateSpanId } from './utils/propagationContext.js';\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {\n    rest[_key] = arguments[_key];\n  }\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n    return acs.withSetScope(scope, callback);\n  }\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  for (var _len2 = arguments.length, rest = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    rest[_key2] = arguments[_key2];\n  }\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext = scope.getPropagationContext();\n  const {\n    traceId,\n    parentSpanId,\n    propagationSpanId\n  } = propagationContext;\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId()\n  };\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n  return traceContext;\n}\nexport { getClient, getCurrentScope, getGlobalScope, getIsolationScope, getTraceContextFromScope, withIsolationScope, withScope };","map":{"version":3,"names":["getCurrentScope","carrier","getMainCarrier","acs","getAsyncContextStrategy","getIsolationScope","getGlobalScope","getGlobalSingleton","Scope","withScope","_len","arguments","length","rest","Array","_key","scope","callback","withSetScope","withIsolationScope","_len2","_key2","isolationScope","withSetIsolationScope","getClient","getTraceContextFromScope","propagationContext","getPropagationContext","traceId","parentSpanId","propagationSpanId","traceContext","trace_id","span_id","generateSpanId","parent_span_id"],"sources":["/workspace/node_modules/@sentry/core/src/currentScopes.ts"],"sourcesContent":["import { getAsyncContextStrategy } from './asyncContext';\nimport { getGlobalSingleton, getMainCarrier } from './carrier';\nimport type { Client } from './client';\nimport { Scope } from './scope';\nimport type { TraceContext } from './types-hoist/context';\nimport { generateSpanId } from './utils/propagationContext';\n\n/**\n * Get the currently active scope.\n */\nexport function getCurrentScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nexport function getIsolationScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nexport function getGlobalScope(): Scope {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\nexport function withScope<T>(callback: (scope: Scope) => T): T;\n/**\n * Set the given scope as the active scope in the callback.\n */\nexport function withScope<T>(scope: Scope | undefined, callback: (scope: Scope) => T): T;\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nexport function withScope<T>(\n  ...rest: [callback: (scope: Scope) => T] | [scope: Scope | undefined, callback: (scope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\nexport function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T;\n/**\n * Set the provided isolation scope as active in the given callback. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * If you pass in `undefined` as a scope, it will fork a new isolation scope, the same as if no scope is passed.\n */\nexport function withIsolationScope<T>(isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T): T;\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nexport function withIsolationScope<T>(\n  ...rest:\n    | [callback: (isolationScope: Scope) => T]\n    | [isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nexport function getClient<C extends Client>(): C | undefined {\n  return getCurrentScope().getClient<C>();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nexport function getTraceContextFromScope(scope: Scope): TraceContext {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext: TraceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}