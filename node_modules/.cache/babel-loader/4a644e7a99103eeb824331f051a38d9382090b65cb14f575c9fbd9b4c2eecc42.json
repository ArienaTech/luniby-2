{"ast":null,"code":"import { browserPerformanceTimeOrigin, spanToJSON, setMeasurement, getActiveSpan, parseUrl, stringMatchesSomePattern, isPrimitive, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, htmlTreeAsString, getComponentName } from '@sentry/core';\nimport { WINDOW } from '../types.js';\nimport { trackClsAsStandaloneSpan } from './cls.js';\nimport { addPerformanceInstrumentationHandler, addLcpInstrumentationHandler, addTtfbInstrumentationHandler, addClsInstrumentationHandler } from './instrument.js';\nimport { trackLcpAsStandaloneSpan } from './lcp.js';\nimport { getBrowserPerformanceAPI, msToSec, startAndEndSpan, extractNetworkProtocol, isMeasurementValue } from './utils.js';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart.js';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry.js';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher.js';\nconst MAX_INT_AS_BYTES = 2147483647;\nlet _performanceCursor = 0;\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nfunction startTrackingWebVitals(_ref) {\n  let {\n    recordClsStandaloneSpans,\n    recordLcpStandaloneSpans,\n    client\n  } = _ref;\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const lcpCleanupCallback = recordLcpStandaloneSpans ? trackLcpAsStandaloneSpan(client) : _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan(client) : _trackCLS();\n    return () => {\n      lcpCleanupCallback?.();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  addPerformanceInstrumentationHandler('longtask', _ref2 => {\n    let {\n      entries\n    } = _ref2;\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    const {\n      op: parentOp,\n      start_timestamp: parentStartTimestamp\n    } = spanToJSON(parent);\n    for (const entry of entries) {\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const duration = msToSec(entry.duration);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n        }\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nfunction startTrackingLongAnimationFrames() {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries()) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n      const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n      const {\n        start_timestamp: parentStartTimestamp,\n        op: parentOp\n      } = spanToJSON(parent);\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n      const attributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      };\n      const initialScript = entry.scripts[0];\n      const {\n        invoker,\n        invokerType,\n        sourceURL,\n        sourceFunctionName,\n        sourceCharPosition\n      } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes\n      });\n    }\n  });\n  observer.observe({\n    type: 'long-animation-frame',\n    buffered: true\n  });\n}\n\n/**\n * Start tracking interaction events.\n */\nfunction startTrackingInteractions() {\n  addPerformanceInstrumentationHandler('event', _ref3 => {\n    let {\n      entries\n    } = _ref3;\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec(browserPerformanceTimeOrigin() + entry.startTime);\n        const duration = msToSec(entry.duration);\n        const spanOptions = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n          }\n        };\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS() {\n  return addClsInstrumentationHandler(_ref4 => {\n    let {\n      metric\n    } = _ref4;\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = {\n      value: metric.value,\n      unit: ''\n    };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP() {\n  return addLcpInstrumentationHandler(_ref5 => {\n    let {\n      metric\n    } = _ref5;\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['lcp'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n    _lcpEntry = entry;\n  }, true);\n}\nfunction _trackTtfb() {\n  return addTtfbInstrumentationHandler(_ref6 => {\n    let {\n      metric\n    } = _ref6;\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n    _measurements['ttfb'] = {\n      value: metric.value,\n      unit: 'millisecond'\n    };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(span, options) {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n  const timeOrigin = msToSec(origin);\n  const performanceEntries = performance.getEntries();\n  const {\n    op,\n    start_timestamp: transactionStartTime\n  } = spanToJSON(span);\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n    // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n    // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n    // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n    // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n    Math.max(0, entry.duration));\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n    switch (entry.entryType) {\n      case 'navigation':\n        {\n          _addNavigationSpans(span, entry, timeOrigin);\n          break;\n        }\n      case 'mark':\n      case 'paint':\n      case 'measure':\n        {\n          _addMeasureSpans(span, entry, startTime, duration, timeOrigin, options.ignorePerformanceApiSpans);\n\n          // capture web vitals\n          const firstHidden = getVisibilityWatcher();\n          // Only report if the page wasn't hidden prior to the web vital.\n          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n          if (entry.name === 'first-paint' && shouldRecord) {\n            _measurements['fp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          if (entry.name === 'first-contentful-paint' && shouldRecord) {\n            _measurements['fcp'] = {\n              value: entry.startTime,\n              unit: 'millisecond'\n            };\n          }\n          break;\n        }\n      case 'resource':\n        {\n          _addResourceSpans(span, entry, entry.name, startTime, duration, timeOrigin, options.ignoreResourceSpans);\n          break;\n        }\n      // Ignore other entry types.\n    }\n  });\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    // If CLS standalone spans are enabled, don't record CLS as a measurement\n    if (!options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    // If LCP standalone spans are enabled, don't record LCP as a measurement\n    if (!options.recordLcpOnPageloadSpan) {\n      delete _measurements.lcp;\n    }\n    Object.entries(_measurements).forEach(_ref7 => {\n      let [measurementName, measurement] = _ref7;\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n    _setWebVitalAttributes(span, options);\n  }\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nfunction _addMeasureSpans(span, entry, startTime, duration, timeOrigin, ignorePerformanceApiSpans) {\n  if (['mark', 'measure'].includes(entry.entryType) && stringMatchesSomePattern(entry.name, ignorePerformanceApiSpans)) {\n    return;\n  }\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n  _addDetailToSpanAttributes(attributes, entry);\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name,\n      op: entry.entryType,\n      attributes\n    });\n  }\n}\nfunction _addDetailToSpanAttributes(attributes, performanceMeasure) {\n  try {\n    // Accessing detail might throw in some browsers (e.g., Firefox) due to security restrictions\n    const detail = performanceMeasure.detail;\n    if (!detail) {\n      return;\n    }\n\n    // Process detail based on its type\n    if (typeof detail === 'object') {\n      // Handle object details\n      for (const [key, value] of Object.entries(detail)) {\n        if (value && isPrimitive(value)) {\n          attributes[`sentry.browser.measure.detail.${key}`] = value;\n        } else if (value !== undefined) {\n          try {\n            // This is user defined so we can't guarantee it's serializable\n            attributes[`sentry.browser.measure.detail.${key}`] = JSON.stringify(value);\n          } catch {\n            // Skip values that can't be stringified\n          }\n        }\n      }\n      return;\n    }\n    if (isPrimitive(detail)) {\n      // Handle primitive details\n      attributes['sentry.browser.measure.detail'] = detail;\n      return;\n    }\n    try {\n      attributes['sentry.browser.measure.detail'] = JSON.stringify(detail);\n    } catch {\n      // Skip if stringification fails\n    }\n  } catch {\n    // Silently ignore any errors when accessing detail\n    // This handles the Firefox \"Permission denied to access object\" error\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nfunction _addNavigationSpans(span, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(span, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(span, entry, event, timeOrigin) {\n  let name = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : event;\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event);\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? {\n        'http.redirect_count': entry.redirectCount\n      } : {})\n    }\n  });\n}\nfunction _getEndPropertyNameForNavigationTiming(event) {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span, entry, timeOrigin) {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics'\n      }\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nfunction _addResourceSpans(span, entry, resourceUrl, startTime, duration, timeOrigin, ignoreResourceSpans) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n  const op = entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other';\n  if (ignoreResourceSpans?.includes(op)) {\n    return;\n  }\n  const parsedUrl = parseUrl(resourceUrl);\n  const attributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics'\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = entry.deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = entry.renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  // Checking for only `undefined` and `null` is intentional because it's\n  // valid for `nextHopProtocol` to be an empty string.\n  if (entry.nextHopProtocol != null) {\n    const {\n      name,\n      version\n    } = extractNetworkProtocol(entry.nextHopProtocol);\n    attributes['network.protocol.name'] = name;\n    attributes['network.protocol.version'] = version;\n  }\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op,\n    attributes\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span) {\n  const navigator = WINDOW.navigator;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = {\n        value: connection.rtt,\n        unit: 'millisecond'\n      };\n    }\n  }\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span, options) {\n  // Only add LCP attributes if LCP is being recorded on the pageload span\n  if (_lcpEntry && options.recordLcpOnPageloadSpan) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // Only add CLS attributes if CLS is being recorded on the pageload span\n  if (_clsEntry?.sources && options.recordClsOnPageloadSpan) {\n    _clsEntry.sources.forEach((source, index) => span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)));\n  }\n}\nfunction setResourceEntrySizeData(attributes, entry, key, dataKey) {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements) {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n  const {\n    responseStart,\n    requestStart\n  } = navEntry;\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond'\n    };\n  }\n}\nexport { _addMeasureSpans, _addNavigationSpans, _addResourceSpans, addPerformanceEntries, startTrackingInteractions, startTrackingLongAnimationFrames, startTrackingLongTasks, startTrackingWebVitals };","map":{"version":3,"names":["MAX_INT_AS_BYTES","_performanceCursor","_measurements","_lcpEntry","_clsEntry","startTrackingWebVitals","_ref","recordClsStandaloneSpans","recordLcpStandaloneSpans","client","performance","getBrowserPerformanceAPI","browserPerformanceTimeOrigin","mark","WINDOW","lcpCleanupCallback","trackLcpAsStandaloneSpan","_trackLCP","ttfbCleanupCallback","_trackTtfb","clsCleanupCallback","trackClsAsStandaloneSpan","_trackCLS","undefined","startTrackingLongTasks","addPerformanceInstrumentationHandler","_ref2","entries","parent","getActiveSpan","op","parentOp","start_timestamp","parentStartTimestamp","spanToJSON","entry","startTime","msToSec","duration","startAndEndSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","startTrackingLongAnimationFrames","observer","PerformanceObserver","list","getEntries","scripts","initialScript","invoker","invokerType","sourceURL","sourceFunctionName","sourceCharPosition","observe","type","buffered","startTrackingInteractions","_ref3","spanOptions","htmlTreeAsString","target","componentName","getComponentName","addClsInstrumentationHandler","_ref4","metric","length","value","unit","addLcpInstrumentationHandler","_ref5","addTtfbInstrumentationHandler","_ref6","addPerformanceEntries","span","options","origin","timeOrigin","performanceEntries","transactionStartTime","slice","forEach","Math","max","entryType","_addNavigationSpans","_addMeasureSpans","ignorePerformanceApiSpans","firstHidden","getVisibilityWatcher","shouldRecord","firstHiddenTime","_addResourceSpans","ignoreResourceSpans","_trackNavigator","_addTtfbRequestTimeToMeasurements","recordClsOnPageloadSpan","cls","recordLcpOnPageloadSpan","lcp","Object","_ref7","measurementName","measurement","setMeasurement","setAttribute","getActivationStart","_setWebVitalAttributes","includes","stringMatchesSomePattern","navEntry","getNavigationEntry","requestTime","requestStart","measureStartTimestamp","startTimeStamp","measureEndTimestamp","_addDetailToSpanAttributes","performanceMeasure","detail","key","isPrimitive","JSON","stringify","event","_addPerformanceNavigationTiming","_addRequest","arguments","eventEnd","_getEndPropertyNameForNavigationTiming","end","start","redirectCount","requestStartTimestamp","responseEndTimestamp","responseEnd","responseStartTimestamp","responseStart","resourceUrl","initiatorType","parsedUrl","parseUrl","setResourceEntrySizeData","deliveryType","renderBlockingStatus","protocol","split","pop","host","location","nextHopProtocol","version","extractNetworkProtocol","startTimestamp","endTimestamp","replace","navigator","connection","effectiveType","isMeasurementValue","rtt","deviceMemory","hardwareConcurrency","String","element","id","url","trim","loadTime","renderTime","size","sources","source","index","node","dataKey","entryVal"],"sources":["/workspace/node_modules/@sentry-internal/browser-utils/src/metrics/browserMetrics.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, Measurements, Span, SpanAttributes, SpanAttributeValue, StartSpanOptions } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getComponentName,\n  htmlTreeAsString,\n  isPrimitive,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  setMeasurement,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport { WINDOW } from '../types';\nimport { trackClsAsStandaloneSpan } from './cls';\nimport {\n  type PerformanceLongAnimationFrameTiming,\n  addClsInstrumentationHandler,\n  addLcpInstrumentationHandler,\n  addPerformanceInstrumentationHandler,\n  addTtfbInstrumentationHandler,\n} from './instrument';\nimport { trackLcpAsStandaloneSpan } from './lcp';\nimport {\n  extractNetworkProtocol,\n  getBrowserPerformanceAPI,\n  isMeasurementValue,\n  msToSec,\n  startAndEndSpan,\n} from './utils';\nimport { getActivationStart } from './web-vitals/lib/getActivationStart';\nimport { getNavigationEntry } from './web-vitals/lib/getNavigationEntry';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\n\ninterface NavigatorNetworkInformation {\n  readonly connection?: NetworkInformation;\n}\n\n// http://wicg.github.io/netinfo/#connection-types\ntype ConnectionType = 'bluetooth' | 'cellular' | 'ethernet' | 'mixed' | 'none' | 'other' | 'unknown' | 'wifi' | 'wimax';\n\n// http://wicg.github.io/netinfo/#effectiveconnectiontype-enum\ntype EffectiveConnectionType = '2g' | '3g' | '4g' | 'slow-2g';\n\n// http://wicg.github.io/netinfo/#dom-megabit\ntype Megabit = number;\n// http://wicg.github.io/netinfo/#dom-millisecond\ntype Millisecond = number;\n\n// http://wicg.github.io/netinfo/#networkinformation-interface\ninterface NetworkInformation extends EventTarget {\n  // http://wicg.github.io/netinfo/#type-attribute\n  readonly type?: ConnectionType;\n  // http://wicg.github.io/netinfo/#effectivetype-attribute\n  readonly effectiveType?: EffectiveConnectionType;\n  // http://wicg.github.io/netinfo/#downlinkmax-attribute\n  readonly downlinkMax?: Megabit;\n  // http://wicg.github.io/netinfo/#downlink-attribute\n  readonly downlink?: Megabit;\n  // http://wicg.github.io/netinfo/#rtt-attribute\n  readonly rtt?: Millisecond;\n  // http://wicg.github.io/netinfo/#savedata-attribute\n  readonly saveData?: boolean;\n  // http://wicg.github.io/netinfo/#handling-changes-to-the-underlying-connection\n  onchange?: EventListener;\n}\n\n// https://w3c.github.io/device-memory/#sec-device-memory-js-api\ninterface NavigatorDeviceMemory {\n  readonly deviceMemory?: number;\n}\n\nconst MAX_INT_AS_BYTES = 2147483647;\n\nlet _performanceCursor: number = 0;\n\nlet _measurements: Measurements = {};\nlet _lcpEntry: LargestContentfulPaint | undefined;\nlet _clsEntry: LayoutShift | undefined;\n\ninterface StartTrackingWebVitalsOptions {\n  recordClsStandaloneSpans: boolean;\n  recordLcpStandaloneSpans: boolean;\n  client: Client;\n}\n\n/**\n * Start tracking web vitals.\n * The callback returned by this function can be used to stop tracking & ensure all measurements are final & captured.\n *\n * @returns A function that forces web vitals collection\n */\nexport function startTrackingWebVitals({\n  recordClsStandaloneSpans,\n  recordLcpStandaloneSpans,\n  client,\n}: StartTrackingWebVitalsOptions): () => void {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin()) {\n    // @ts-expect-error we want to make sure all of these are available, even if TS is sure they are\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    const lcpCleanupCallback = recordLcpStandaloneSpans ? trackLcpAsStandaloneSpan(client) : _trackLCP();\n    const ttfbCleanupCallback = _trackTtfb();\n    const clsCleanupCallback = recordClsStandaloneSpans ? trackClsAsStandaloneSpan(client) : _trackCLS();\n\n    return (): void => {\n      lcpCleanupCallback?.();\n      ttfbCleanupCallback();\n      clsCleanupCallback?.();\n    };\n  }\n\n  return () => undefined;\n}\n\n/**\n * Start tracking long tasks.\n */\nexport function startTrackingLongTasks(): void {\n  addPerformanceInstrumentationHandler('longtask', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n\n    const { op: parentOp, start_timestamp: parentStartTimestamp } = spanToJSON(parent);\n\n    for (const entry of entries) {\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding a span if the long task started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n        },\n      });\n    }\n  });\n}\n\n/**\n * Start tracking long animation frames.\n */\nexport function startTrackingLongAnimationFrames(): void {\n  // NOTE: the current web-vitals version (3.5.2) does not support long-animation-frame, so\n  // we directly observe `long-animation-frame` events instead of through the web-vitals\n  // `observe` helper function.\n  const observer = new PerformanceObserver(list => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of list.getEntries() as PerformanceLongAnimationFrameTiming[]) {\n      if (!entry.scripts[0]) {\n        continue;\n      }\n\n      const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n\n      const { start_timestamp: parentStartTimestamp, op: parentOp } = spanToJSON(parent);\n\n      if (parentOp === 'navigation' && parentStartTimestamp && startTime < parentStartTimestamp) {\n        // Skip adding the span if the long animation frame started before the navigation started.\n        // `startAndEndSpan` will otherwise adjust the parent's start time to the span's start\n        // time, potentially skewing the duration of the actual navigation as reported via our\n        // routing instrumentations\n        continue;\n      }\n      const duration = msToSec(entry.duration);\n\n      const attributes: SpanAttributes = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      };\n\n      const initialScript = entry.scripts[0];\n      const { invoker, invokerType, sourceURL, sourceFunctionName, sourceCharPosition } = initialScript;\n      attributes['browser.script.invoker'] = invoker;\n      attributes['browser.script.invoker_type'] = invokerType;\n      if (sourceURL) {\n        attributes['code.filepath'] = sourceURL;\n      }\n      if (sourceFunctionName) {\n        attributes['code.function'] = sourceFunctionName;\n      }\n      if (sourceCharPosition !== -1) {\n        attributes['browser.script.source_char_position'] = sourceCharPosition;\n      }\n\n      startAndEndSpan(parent, startTime, startTime + duration, {\n        name: 'Main UI thread blocked',\n        op: 'ui.long-animation-frame',\n        attributes,\n      });\n    }\n  });\n\n  observer.observe({ type: 'long-animation-frame', buffered: true });\n}\n\n/**\n * Start tracking interaction events.\n */\nexport function startTrackingInteractions(): void {\n  addPerformanceInstrumentationHandler('event', ({ entries }) => {\n    const parent = getActiveSpan();\n    if (!parent) {\n      return;\n    }\n    for (const entry of entries) {\n      if (entry.name === 'click') {\n        const startTime = msToSec((browserPerformanceTimeOrigin() as number) + entry.startTime);\n        const duration = msToSec(entry.duration);\n\n        const spanOptions: StartSpanOptions & Required<Pick<StartSpanOptions, 'attributes'>> = {\n          name: htmlTreeAsString(entry.target),\n          op: `ui.interaction.${entry.name}`,\n          startTime: startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n          },\n        };\n\n        const componentName = getComponentName(entry.target);\n        if (componentName) {\n          spanOptions.attributes['ui.component_name'] = componentName;\n        }\n\n        startAndEndSpan(parent, startTime, startTime + duration, spanOptions);\n      }\n    }\n  });\n}\n\nexport { registerInpInteractionListener, startTrackingINP } from './inp';\n\n/**\n * Starts tracking the Cumulative Layout Shift on the current page and collects the value and last entry\n * to the `_measurements` object which ultimately is applied to the pageload span's measurements.\n */\nfunction _trackCLS(): () => void {\n  return addClsInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1] as LayoutShift | undefined;\n    if (!entry) {\n      return;\n    }\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry;\n  }, true);\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(): () => void {\n  return addLcpInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry as LargestContentfulPaint;\n  }, true);\n}\n\nfunction _trackTtfb(): () => void {\n  return addTtfbInstrumentationHandler(({ metric }) => {\n    const entry = metric.entries[metric.entries.length - 1];\n    if (!entry) {\n      return;\n    }\n\n    _measurements['ttfb'] = { value: metric.value, unit: 'millisecond' };\n  });\n}\n\ninterface AddPerformanceEntriesOptions {\n  /**\n   * Flag to determine if CLS should be recorded as a measurement on the pageload span or\n   * sent as a standalone span instead.\n   * Sending it as a standalone span will yield more accurate LCP values.\n   *\n   * Default: `false` for backwards compatibility.\n   */\n  recordClsOnPageloadSpan: boolean;\n\n  /**\n   * Flag to determine if LCP should be recorded as a measurement on the pageload span or\n   * sent as a standalone span instead.\n   * Sending it as a standalone span will yield more accurate LCP values.\n   *\n   * Default: `false` for backwards compatibility.\n   */\n  recordLcpOnPageloadSpan: boolean;\n\n  /**\n   * Resource spans with `op`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignoreResourceSpans: Array<'resouce.script' | 'resource.css' | 'resource.img' | 'resource.other' | string>;\n\n  /**\n   * Performance spans created from browser Performance APIs,\n   * `performance.mark(...)` nand `performance.measure(...)`\n   * with `name`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignorePerformanceApiSpans: Array<string | RegExp>;\n}\n\n/** Add performance related spans to a transaction */\nexport function addPerformanceEntries(span: Span, options: AddPerformanceEntriesOptions): void {\n  const performance = getBrowserPerformanceAPI();\n  const origin = browserPerformanceTimeOrigin();\n  if (!performance?.getEntries || !origin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  const timeOrigin = msToSec(origin);\n\n  const performanceEntries = performance.getEntries();\n\n  const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n\n  performanceEntries.slice(_performanceCursor).forEach(entry => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(\n      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.\n      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display\n      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.\n      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.\n      Math.max(0, entry.duration),\n    );\n\n    if (op === 'navigation' && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(span, entry as PerformanceNavigationTiming, timeOrigin);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(span, entry, startTime, duration, timeOrigin, options.ignorePerformanceApiSpans);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        _addResourceSpans(\n          span,\n          entry as PerformanceResourceTiming,\n          entry.name,\n          startTime,\n          duration,\n          timeOrigin,\n          options.ignoreResourceSpans,\n        );\n        break;\n      }\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(span);\n\n  // Measurements are only available for pageload transactions\n  if (op === 'pageload') {\n    _addTtfbRequestTimeToMeasurements(_measurements);\n\n    // If CLS standalone spans are enabled, don't record CLS as a measurement\n    if (!options.recordClsOnPageloadSpan) {\n      delete _measurements.cls;\n    }\n\n    // If LCP standalone spans are enabled, don't record LCP as a measurement\n    if (!options.recordLcpOnPageloadSpan) {\n      delete _measurements.lcp;\n    }\n\n    Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n      setMeasurement(measurementName, measurement.value, measurement.unit);\n    });\n\n    // Set timeOrigin which denotes the timestamp which to base the LCP/FCP/FP/TTFB measurements on\n    span.setAttribute('performance.timeOrigin', timeOrigin);\n\n    // In prerendering scenarios, where a page might be prefetched and pre-rendered before the user clicks the link,\n    // the navigation starts earlier than when the user clicks it. Web Vitals should always be based on the\n    // user-perceived time, so they are not reported from the actual start of the navigation, but rather from the\n    // time where the user actively started the navigation, for example by clicking a link.\n    // This is user action is called \"activation\" and the time between navigation and activation is stored in\n    // the `activationStart` attribute of the \"navigation\" PerformanceEntry.\n    span.setAttribute('performance.activationStart', getActivationStart());\n\n    _setWebVitalAttributes(span, options);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/**\n * Create measure related spans.\n * Exported only for tests.\n */\nexport function _addMeasureSpans(\n  span: Span,\n  entry: PerformanceEntry,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n  ignorePerformanceApiSpans: AddPerformanceEntriesOptions['ignorePerformanceApiSpans'],\n): void {\n  if (\n    ['mark', 'measure'].includes(entry.entryType) &&\n    stringMatchesSomePattern(entry.name, ignorePerformanceApiSpans)\n  ) {\n    return;\n  }\n\n  const navEntry = getNavigationEntry(false);\n  const requestTime = msToSec(navEntry ? navEntry.requestStart : 0);\n  // Because performance.measure accepts arbitrary timestamps it can produce\n  // spans that happen before the browser even makes a request for the page.\n  //\n  // An example of this is the automatically generated Next.js-before-hydration\n  // spans created by the Next.js framework.\n  //\n  // To prevent this we will pin the start timestamp to the request start time\n  // This does make duration inaccurate, so if this does happen, we will add\n  // an attribute to the span\n  const measureStartTimestamp = timeOrigin + Math.max(startTime, requestTime);\n  const startTimeStamp = timeOrigin + startTime;\n  const measureEndTimestamp = startTimeStamp + duration;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n\n  if (measureStartTimestamp !== startTimeStamp) {\n    attributes['sentry.browser.measure_happened_before_request'] = true;\n    attributes['sentry.browser.measure_start_time'] = measureStartTimestamp;\n  }\n\n  _addDetailToSpanAttributes(attributes, entry as PerformanceMeasure);\n\n  // Measurements from third parties can be off, which would create invalid spans, dropping transactions in the process.\n  if (measureStartTimestamp <= measureEndTimestamp) {\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name as string,\n      op: entry.entryType as string,\n      attributes,\n    });\n  }\n}\n\nfunction _addDetailToSpanAttributes(attributes: SpanAttributes, performanceMeasure: PerformanceMeasure): void {\n  try {\n    // Accessing detail might throw in some browsers (e.g., Firefox) due to security restrictions\n    const detail = performanceMeasure.detail;\n\n    if (!detail) {\n      return;\n    }\n\n    // Process detail based on its type\n    if (typeof detail === 'object') {\n      // Handle object details\n      for (const [key, value] of Object.entries(detail)) {\n        if (value && isPrimitive(value)) {\n          attributes[`sentry.browser.measure.detail.${key}`] = value as SpanAttributeValue;\n        } else if (value !== undefined) {\n          try {\n            // This is user defined so we can't guarantee it's serializable\n            attributes[`sentry.browser.measure.detail.${key}`] = JSON.stringify(value);\n          } catch {\n            // Skip values that can't be stringified\n          }\n        }\n      }\n      return;\n    }\n\n    if (isPrimitive(detail)) {\n      // Handle primitive details\n      attributes['sentry.browser.measure.detail'] = detail as SpanAttributeValue;\n      return;\n    }\n\n    try {\n      attributes['sentry.browser.measure.detail'] = JSON.stringify(detail);\n    } catch {\n      // Skip if stringification fails\n    }\n  } catch {\n    // Silently ignore any errors when accessing detail\n    // This handles the Firefox \"Permission denied to access object\" error\n  }\n}\n\n/**\n * Instrument navigation entries\n * exported only for tests\n */\nexport function _addNavigationSpans(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  (['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'] as const).forEach(event => {\n    _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(span, entry, 'secureConnection', timeOrigin, 'TLS/SSL');\n  _addPerformanceNavigationTiming(span, entry, 'fetch', timeOrigin, 'cache');\n  _addPerformanceNavigationTiming(span, entry, 'domainLookup', timeOrigin, 'DNS');\n\n  _addRequest(span, entry, timeOrigin);\n}\n\ntype StartEventName =\n  | 'secureConnection'\n  | 'fetch'\n  | 'domainLookup'\n  | 'unloadEvent'\n  | 'redirect'\n  | 'connect'\n  | 'domContentLoadedEvent'\n  | 'loadEvent';\n\ntype EndEventName =\n  | 'connectEnd'\n  | 'domainLookupStart'\n  | 'domainLookupEnd'\n  | 'unloadEventEnd'\n  | 'redirectEnd'\n  | 'connectEnd'\n  | 'domContentLoadedEventEnd'\n  | 'loadEventEnd';\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  span: Span,\n  entry: PerformanceNavigationTiming,\n  event: StartEventName,\n  timeOrigin: number,\n  name: string = event,\n): void {\n  const eventEnd = _getEndPropertyNameForNavigationTiming(event) satisfies keyof PerformanceNavigationTiming;\n  const end = entry[eventEnd];\n  const start = entry[`${event}Start`];\n  if (!start || !end) {\n    return;\n  }\n  startAndEndSpan(span, timeOrigin + msToSec(start), timeOrigin + msToSec(end), {\n    op: `browser.${name}`,\n    name: entry.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      ...(event === 'redirect' && entry.redirectCount != null ? { 'http.redirect_count': entry.redirectCount } : {}),\n    },\n  });\n}\n\nfunction _getEndPropertyNameForNavigationTiming(event: StartEventName): EndEventName {\n  if (event === 'secureConnection') {\n    return 'connectEnd';\n  }\n  if (event === 'fetch') {\n    return 'domainLookupStart';\n  }\n  return `${event}End`;\n}\n\n/** Create request and response related spans */\nfunction _addRequest(span: Span, entry: PerformanceNavigationTiming, timeOrigin: number): void {\n  const requestStartTimestamp = timeOrigin + msToSec(entry.requestStart as number);\n  const responseEndTimestamp = timeOrigin + msToSec(entry.responseEnd as number);\n  const responseStartTimestamp = timeOrigin + msToSec(entry.responseStart as number);\n  if (entry.responseEnd) {\n    // It is possible that we are collecting these metrics when the page hasn't finished loading yet, for example when the HTML slowly streams in.\n    // In this case, ie. when the document request hasn't finished yet, `entry.responseEnd` will be 0.\n    // In order not to produce faulty spans, where the end timestamp is before the start timestamp, we will only collect\n    // these spans when the responseEnd value is available. The backend (Relay) would drop the entire span if it contained faulty spans.\n    startAndEndSpan(span, requestStartTimestamp, responseEndTimestamp, {\n      op: 'browser.request',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n\n    startAndEndSpan(span, responseStartTimestamp, responseEndTimestamp, {\n      op: 'browser.response',\n      name: entry.name,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.browser.metrics',\n      },\n    });\n  }\n}\n\n/**\n * Create resource-related spans.\n * Exported only for tests.\n */\nexport function _addResourceSpans(\n  span: Span,\n  entry: PerformanceResourceTiming,\n  resourceUrl: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n  ignoreResourceSpans?: Array<string>,\n): void {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const op = entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other';\n  if (ignoreResourceSpans?.includes(op)) {\n    return;\n  }\n\n  const parsedUrl = parseUrl(resourceUrl);\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.resource.browser.metrics',\n  };\n  setResourceEntrySizeData(attributes, entry, 'transferSize', 'http.response_transfer_size');\n  setResourceEntrySizeData(attributes, entry, 'encodedBodySize', 'http.response_content_length');\n  setResourceEntrySizeData(attributes, entry, 'decodedBodySize', 'http.decoded_response_content_length');\n\n  // `deliveryType` is experimental and does not exist everywhere\n  const deliveryType = (entry as { deliveryType?: 'cache' | 'navigational-prefetch' | '' }).deliveryType;\n  if (deliveryType != null) {\n    attributes['http.response_delivery_type'] = deliveryType;\n  }\n\n  // Types do not reflect this property yet\n  const renderBlockingStatus = (entry as { renderBlockingStatus?: 'render-blocking' | 'non-render-blocking' })\n    .renderBlockingStatus;\n  if (renderBlockingStatus) {\n    attributes['resource.render_blocking_status'] = renderBlockingStatus;\n  }\n\n  if (parsedUrl.protocol) {\n    attributes['url.scheme'] = parsedUrl.protocol.split(':').pop(); // the protocol returned by parseUrl includes a :, but OTEL spec does not, so we remove it.\n  }\n\n  if (parsedUrl.host) {\n    attributes['server.address'] = parsedUrl.host;\n  }\n\n  attributes['url.same_origin'] = resourceUrl.includes(WINDOW.location.origin);\n\n  // Checking for only `undefined` and `null` is intentional because it's\n  // valid for `nextHopProtocol` to be an empty string.\n  if (entry.nextHopProtocol != null) {\n    const { name, version } = extractNetworkProtocol(entry.nextHopProtocol);\n    attributes['network.protocol.name'] = name;\n    attributes['network.protocol.version'] = version;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  startAndEndSpan(span, startTimestamp, endTimestamp, {\n    name: resourceUrl.replace(WINDOW.location.origin, ''),\n    op,\n    attributes,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(span: Span): void {\n  const navigator = WINDOW.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      span.setAttribute('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      span.setAttribute('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    span.setAttribute('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    span.setAttribute('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to span to allow debugging */\nfunction _setWebVitalAttributes(span: Span, options: AddPerformanceEntriesOptions): void {\n  // Only add LCP attributes if LCP is being recorded on the pageload span\n  if (_lcpEntry && options.recordLcpOnPageloadSpan) {\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      span.setAttribute('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      span.setAttribute('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      span.setAttribute('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    if (_lcpEntry.loadTime != null) {\n      // loadTime is the time of LCP that's related to receiving the LCP element response..\n      span.setAttribute('lcp.loadTime', _lcpEntry.loadTime);\n    }\n\n    if (_lcpEntry.renderTime != null) {\n      // renderTime is loadTime + rendering time\n      // it's 0 if the LCP element is loaded from a 3rd party origin that doesn't send the\n      // `Timing-Allow-Origin` header.\n      span.setAttribute('lcp.renderTime', _lcpEntry.renderTime);\n    }\n\n    span.setAttribute('lcp.size', _lcpEntry.size);\n  }\n\n  // Only add CLS attributes if CLS is being recorded on the pageload span\n  if (_clsEntry?.sources && options.recordClsOnPageloadSpan) {\n    _clsEntry.sources.forEach((source, index) =>\n      span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nfunction setResourceEntrySizeData(\n  attributes: SpanAttributes,\n  entry: PerformanceResourceTiming,\n  key: keyof Pick<PerformanceResourceTiming, 'transferSize' | 'encodedBodySize' | 'decodedBodySize'>,\n  dataKey: 'http.response_transfer_size' | 'http.response_content_length' | 'http.decoded_response_content_length',\n): void {\n  const entryVal = entry[key];\n  if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n    attributes[dataKey] = entryVal;\n  }\n}\n\n/**\n * Add ttfb request time information to measurements.\n *\n * ttfb information is added via vendored web vitals library.\n */\nfunction _addTtfbRequestTimeToMeasurements(_measurements: Measurements): void {\n  const navEntry = getNavigationEntry(false);\n  if (!navEntry) {\n    return;\n  }\n\n  const { responseStart, requestStart } = navEntry;\n\n  if (requestStart <= responseStart) {\n    _measurements['ttfb.requestTime'] = {\n      value: responseStart - requestStart,\n      unit: 'millisecond',\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}