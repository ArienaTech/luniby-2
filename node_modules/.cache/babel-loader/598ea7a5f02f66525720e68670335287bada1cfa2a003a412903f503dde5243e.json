{"ast":null,"code":"import { DEBUG_BUILD } from '../debug-build.js';\nimport { consoleSandbox, debug } from './debug-logger.js';\n\n/** Regular expression used to extract org ID from a DSN host. */\nconst ORG_ID_REGEX = /^o(\\d+)\\./;\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn) {\n  let withPassword = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const {\n    host,\n    path,\n    pass,\n    port,\n    projectId,\n    protocol,\n    publicKey\n  } = dsn;\n  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` + `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`;\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nfunction dsnFromString(str) {\n  const match = DSN_REGEX.exec(str);\n  if (!match) {\n    // This should be logged to the console\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid Sentry Dsn: ${str}`);\n    });\n    return undefined;\n  }\n  const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop();\n  }\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n  return dsnFromComponents({\n    host,\n    pass,\n    path,\n    projectId,\n    port,\n    protocol: protocol,\n    publicKey\n  });\n}\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId\n  };\n}\nfunction validateDsn(dsn) {\n  if (!DEBUG_BUILD) {\n    return true;\n  }\n  const {\n    port,\n    projectId,\n    protocol\n  } = dsn;\n  const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      debug.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n  if (!projectId.match(/^\\d+$/)) {\n    debug.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n  if (!isValidProtocol(protocol)) {\n    debug.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n  if (port && isNaN(parseInt(port, 10))) {\n    debug.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Extract the org ID from a DSN host.\n *\n * @param host The host from a DSN\n * @returns The org ID if found, undefined otherwise\n */\nfunction extractOrgIdFromDsnHost(host) {\n  const match = host.match(ORG_ID_REGEX);\n  return match?.[1];\n}\n\n/**\n *  Returns the organization ID of the client.\n *\n *  The organization ID is extracted from the DSN. If the client options include a `orgId`, this will always take precedence.\n */\nfunction extractOrgIdFromClient(client) {\n  const options = client.getOptions();\n  const {\n    host\n  } = client.getDsn() || {};\n  let org_id;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = extractOrgIdFromDsnHost(host);\n  }\n  return org_id;\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nfunction makeDsn(from) {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\nexport { dsnFromString, dsnToString, extractOrgIdFromClient, extractOrgIdFromDsnHost, makeDsn };","map":{"version":3,"names":["ORG_ID_REGEX","DSN_REGEX","isValidProtocol","protocol","dsnToString","dsn","withPassword","arguments","length","undefined","host","path","pass","port","projectId","publicKey","dsnFromString","str","match","exec","consoleSandbox","console","error","lastPath","slice","split","join","pop","projectMatch","dsnFromComponents","components","validateDsn","DEBUG_BUILD","requiredComponents","hasMissingRequiredComponent","find","component","debug","isNaN","parseInt","extractOrgIdFromDsnHost","extractOrgIdFromClient","client","options","getOptions","getDsn","org_id","orgId","String","makeDsn","from"],"sources":["/workspace/node_modules/@sentry/core/src/utils/dsn.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { DsnComponents, DsnLike, DsnProtocol } from '../types-hoist/dsn';\nimport { consoleSandbox, debug } from './debug-logger';\n\n/** Regular expression used to extract org ID from a DSN host. */\nconst ORG_ID_REGEX = /^o(\\d+)\\./;\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nexport function dsnFromString(str: string): DsnComponents | undefined {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    // This should be logged to the console\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid Sentry Dsn: ${str}`);\n    });\n    return undefined;\n  }\n\n  const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean {\n  if (!DEBUG_BUILD) {\n    return true;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      debug.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n\n  if (!projectId.match(/^\\d+$/)) {\n    debug.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n\n  if (!isValidProtocol(protocol)) {\n    debug.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    debug.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Extract the org ID from a DSN host.\n *\n * @param host The host from a DSN\n * @returns The org ID if found, undefined otherwise\n */\nexport function extractOrgIdFromDsnHost(host: string): string | undefined {\n  const match = host.match(ORG_ID_REGEX);\n\n  return match?.[1];\n}\n\n/**\n *  Returns the organization ID of the client.\n *\n *  The organization ID is extracted from the DSN. If the client options include a `orgId`, this will always take precedence.\n */\nexport function extractOrgIdFromClient(client: Client): string | undefined {\n  const options = client.getOptions();\n\n  const { host } = client.getDsn() || {};\n\n  let org_id: string | undefined;\n\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = extractOrgIdFromDsnHost(host);\n  }\n\n  return org_id;\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nexport function makeDsn(from: DsnLike): DsnComponents | undefined {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}