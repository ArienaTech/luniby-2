{"ast":null,"code":"import { getCurrentScope } from '../../currentScopes.js';\nimport { captureException } from '../../exports.js';\nimport { SPAN_STATUS_ERROR } from '../../tracing/spanstatus.js';\nimport { startSpanManual, startSpan } from '../../tracing/trace.js';\nimport { GEN_AI_OPERATION_NAME_ATTRIBUTE, GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE, GEN_AI_REQUEST_MODEL_ATTRIBUTE, GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE, GEN_AI_REQUEST_TOP_P_ATTRIBUTE, GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE, GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE, GEN_AI_REQUEST_STREAM_ATTRIBUTE, GEN_AI_REQUEST_MESSAGES_ATTRIBUTE, GEN_AI_RESPONSE_TEXT_ATTRIBUTE, GEN_AI_SYSTEM_ATTRIBUTE, GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE, GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE } from '../gen-ai-attributes.js';\nimport { OPENAI_INTEGRATION_NAME } from './constants.js';\nimport { instrumentStream } from './streaming.js';\nimport { shouldInstrument, getOperationName, getSpanOperation, isChatCompletionResponse, isResponsesApiResponse, setCommonResponseAttributes, setTokenUsageAttributes, buildMethodPath } from './utils.js';\n\n/**\n * Extract request attributes from method arguments\n */\nfunction extractRequestAttributes(args, methodPath) {\n  const attributes = {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: 'openai',\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getOperationName(methodPath)\n  };\n\n  // Chat completion API accepts web_search_options and tools as parameters\n  // we append web search options to the available tools to capture all tool calls\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0];\n    const tools = Array.isArray(params.tools) ? params.tools : [];\n    const hasWebSearchOptions = params.web_search_options && typeof params.web_search_options === 'object';\n    const webSearchOptions = hasWebSearchOptions ? [{\n      type: 'web_search_options',\n      ...params.web_search_options\n    }] : [];\n    const availableTools = [...tools, ...webSearchOptions];\n    if (availableTools.length > 0) {\n      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(availableTools);\n    }\n  }\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0];\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? 'unknown';\n    if ('temperature' in params) attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;\n    if ('top_p' in params) attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;\n    if ('frequency_penalty' in params) attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;\n    if ('presence_penalty' in params) attributes[GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = params.presence_penalty;\n    if ('stream' in params) attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;\n  } else {\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';\n  }\n  return attributes;\n}\n\n/**\n * Add attributes for Chat Completion responses\n */\nfunction addChatCompletionAttributes(span, response, recordOutputs) {\n  setCommonResponseAttributes(span, response.id, response.model, response.created);\n  if (response.usage) {\n    setTokenUsageAttributes(span, response.usage.prompt_tokens, response.usage.completion_tokens, response.usage.total_tokens);\n  }\n  if (Array.isArray(response.choices)) {\n    const finishReasons = response.choices.map(choice => choice.finish_reason).filter(reason => reason !== null);\n    if (finishReasons.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(finishReasons)\n      });\n    }\n\n    // Extract tool calls from all choices (only if recordOutputs is true)\n    if (recordOutputs) {\n      const toolCalls = response.choices.map(choice => choice.message?.tool_calls).filter(calls => Array.isArray(calls) && calls.length > 0).flat();\n      if (toolCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls)\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add attributes for Responses API responses\n */\nfunction addResponsesApiAttributes(span, response, recordOutputs) {\n  setCommonResponseAttributes(span, response.id, response.model, response.created_at);\n  if (response.status) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify([response.status])\n    });\n  }\n  if (response.usage) {\n    setTokenUsageAttributes(span, response.usage.input_tokens, response.usage.output_tokens, response.usage.total_tokens);\n  }\n\n  // Extract function calls from output (only if recordOutputs is true)\n  if (recordOutputs) {\n    const responseWithOutput = response;\n    if (Array.isArray(responseWithOutput.output) && responseWithOutput.output.length > 0) {\n      // Filter for function_call type objects in the output array\n      const functionCalls = responseWithOutput.output.filter(item => typeof item === 'object' && item !== null && item.type === 'function_call');\n      if (functionCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(functionCalls)\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add response attributes to spans\n * This currently supports both Chat Completion and Responses API responses\n */\nfunction addResponseAttributes(span, result, recordOutputs) {\n  if (!result || typeof result !== 'object') return;\n  const response = result;\n  if (isChatCompletionResponse(response)) {\n    addChatCompletionAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.choices?.length) {\n      const responseTexts = response.choices.map(choice => choice.message?.content || '');\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(responseTexts)\n      });\n    }\n  } else if (isResponsesApiResponse(response)) {\n    addResponsesApiAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.output_text) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.output_text\n      });\n    }\n  }\n}\n\n// Extract and record AI request inputs, if present. This is intentionally separate from response attributes.\nfunction addRequestAttributes(span, params) {\n  if ('messages' in params) {\n    span.setAttributes({\n      [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.messages)\n    });\n  }\n  if ('input' in params) {\n    span.setAttributes({\n      [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.input)\n    });\n  }\n}\nfunction getOptionsFromIntegration() {\n  const scope = getCurrentScope();\n  const client = scope.getClient();\n  const integration = client?.getIntegrationByName(OPENAI_INTEGRATION_NAME);\n  const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n  return {\n    recordInputs: integration?.options?.recordInputs ?? shouldRecordInputsAndOutputs,\n    recordOutputs: integration?.options?.recordOutputs ?? shouldRecordInputsAndOutputs\n  };\n}\n\n/**\n * Instrument a method with Sentry spans\n * Following Sentry AI Agents Manual Instrumentation conventions\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod(originalMethod, methodPath, context, options) {\n  return async function instrumentedMethod() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const finalOptions = options || getOptionsFromIntegration();\n    const requestAttributes = extractRequestAttributes(args, methodPath);\n    const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] || 'unknown';\n    const operationName = getOperationName(methodPath);\n    const params = args[0];\n    const isStreamRequested = params && typeof params === 'object' && params.stream === true;\n    if (isStreamRequested) {\n      // For streaming responses, use manual span management to properly handle the async generator lifecycle\n      return startSpanManual({\n        name: `${operationName} ${model} stream-response`,\n        op: getSpanOperation(methodPath),\n        attributes: requestAttributes\n      }, async span => {\n        try {\n          if (finalOptions.recordInputs && args[0] && typeof args[0] === 'object') {\n            addRequestAttributes(span, args[0]);\n          }\n          const result = await originalMethod.apply(context, args);\n          return instrumentStream(result, span, finalOptions.recordOutputs ?? false);\n        } catch (error) {\n          // For streaming requests that fail before stream creation, we still want to record\n          // them as streaming requests but end the span gracefully\n          span.setStatus({\n            code: SPAN_STATUS_ERROR,\n            message: 'internal_error'\n          });\n          captureException(error, {\n            mechanism: {\n              handled: false\n            }\n          });\n          span.end();\n          throw error;\n        }\n      });\n    } else {\n      //  Non-streaming responses\n      return startSpan({\n        name: `${operationName} ${model}`,\n        op: getSpanOperation(methodPath),\n        attributes: requestAttributes\n      }, async span => {\n        try {\n          if (finalOptions.recordInputs && args[0] && typeof args[0] === 'object') {\n            addRequestAttributes(span, args[0]);\n          }\n          const result = await originalMethod.apply(context, args);\n          addResponseAttributes(span, result, finalOptions.recordOutputs);\n          return result;\n        } catch (error) {\n          captureException(error);\n          throw error;\n        }\n      });\n    }\n  };\n}\n\n/**\n * Create a deep proxy for OpenAI client instrumentation\n */\nfunction createDeepProxy(target) {\n  let currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  return new Proxy(target, {\n    get(obj, prop) {\n      const value = obj[prop];\n      const methodPath = buildMethodPath(currentPath, String(prop));\n      if (typeof value === 'function' && shouldInstrument(methodPath)) {\n        return instrumentMethod(value, methodPath, obj, options);\n      }\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context,\n        // which is required for accessing private class fields (e.g. #baseURL) in OpenAI SDK v5.\n        return value.bind(obj);\n      }\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value, methodPath, options);\n      }\n      return value;\n    }\n  });\n}\n\n/**\n * Instrument an OpenAI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n */\nfunction instrumentOpenAiClient(client, options) {\n  return createDeepProxy(client, '', options);\n}\nexport { instrumentOpenAiClient };","map":{"version":3,"names":["extractRequestAttributes","args","methodPath","attributes","GEN_AI_SYSTEM_ATTRIBUTE","GEN_AI_OPERATION_NAME_ATTRIBUTE","getOperationName","length","params","tools","Array","isArray","hasWebSearchOptions","web_search_options","webSearchOptions","type","availableTools","GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE","JSON","stringify","GEN_AI_REQUEST_MODEL_ATTRIBUTE","model","GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE","temperature","GEN_AI_REQUEST_TOP_P_ATTRIBUTE","top_p","GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE","frequency_penalty","GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE","presence_penalty","GEN_AI_REQUEST_STREAM_ATTRIBUTE","stream","addChatCompletionAttributes","span","response","recordOutputs","setCommonResponseAttributes","id","created","usage","setTokenUsageAttributes","prompt_tokens","completion_tokens","total_tokens","choices","finishReasons","map","choice","finish_reason","filter","reason","setAttributes","GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE","toolCalls","message","tool_calls","calls","flat","GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE","addResponsesApiAttributes","created_at","status","input_tokens","output_tokens","responseWithOutput","output","functionCalls","item","addResponseAttributes","result","isChatCompletionResponse","responseTexts","content","GEN_AI_RESPONSE_TEXT_ATTRIBUTE","isResponsesApiResponse","output_text","addRequestAttributes","GEN_AI_REQUEST_MESSAGES_ATTRIBUTE","messages","input","getOptionsFromIntegration","scope","getCurrentScope","client","getClient","integration","getIntegrationByName","OPENAI_INTEGRATION_NAME","shouldRecordInputsAndOutputs","Boolean","getOptions","sendDefaultPii","recordInputs","options","instrumentMethod","originalMethod","context","instrumentedMethod","_len","arguments","_key","finalOptions","requestAttributes","operationName","isStreamRequested","startSpanManual","name","op","getSpanOperation","apply","instrumentStream","error","setStatus","code","SPAN_STATUS_ERROR","captureException","mechanism","handled","end","startSpan","createDeepProxy","target","currentPath","undefined","Proxy","get","obj","prop","value","buildMethodPath","String","shouldInstrument","bind","instrumentOpenAiClient"],"sources":["/workspace/node_modules/@sentry/core/src/utils/openai/index.ts"],"sourcesContent":["import { getCurrentScope } from '../../currentScopes';\nimport { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport { startSpan, startSpanManual } from '../../tracing/trace';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport {\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE,\n  GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_REQUEST_MODEL_ATTRIBUTE,\n  GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_STREAM_ATTRIBUTE,\n  GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_P_ATTRIBUTE,\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_SYSTEM_ATTRIBUTE,\n} from '../gen-ai-attributes';\nimport { OPENAI_INTEGRATION_NAME } from './constants';\nimport { instrumentStream } from './streaming';\nimport type {\n  ChatCompletionChunk,\n  InstrumentedMethod,\n  OpenAiChatCompletionObject,\n  OpenAiClient,\n  OpenAiIntegration,\n  OpenAiOptions,\n  OpenAiResponse,\n  OpenAIResponseObject,\n  OpenAIStream,\n  ResponseStreamingEvent,\n} from './types';\nimport {\n  buildMethodPath,\n  getOperationName,\n  getSpanOperation,\n  isChatCompletionResponse,\n  isResponsesApiResponse,\n  setCommonResponseAttributes,\n  setTokenUsageAttributes,\n  shouldInstrument,\n} from './utils';\n\n/**\n * Extract request attributes from method arguments\n */\nfunction extractRequestAttributes(args: unknown[], methodPath: string): Record<string, unknown> {\n  const attributes: Record<string, unknown> = {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: 'openai',\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getOperationName(methodPath),\n  };\n\n  // Chat completion API accepts web_search_options and tools as parameters\n  // we append web search options to the available tools to capture all tool calls\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] as Record<string, unknown>;\n\n    const tools = Array.isArray(params.tools) ? params.tools : [];\n    const hasWebSearchOptions = params.web_search_options && typeof params.web_search_options === 'object';\n    const webSearchOptions = hasWebSearchOptions\n      ? [{ type: 'web_search_options', ...(params.web_search_options as Record<string, unknown>) }]\n      : [];\n\n    const availableTools = [...tools, ...webSearchOptions];\n\n    if (availableTools.length > 0) {\n      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(availableTools);\n    }\n  }\n\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] as Record<string, unknown>;\n\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? 'unknown';\n    if ('temperature' in params) attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;\n    if ('top_p' in params) attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;\n    if ('frequency_penalty' in params)\n      attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;\n    if ('presence_penalty' in params) attributes[GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = params.presence_penalty;\n    if ('stream' in params) attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;\n  } else {\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';\n  }\n\n  return attributes;\n}\n\n/**\n * Add attributes for Chat Completion responses\n */\nfunction addChatCompletionAttributes(span: Span, response: OpenAiChatCompletionObject, recordOutputs?: boolean): void {\n  setCommonResponseAttributes(span, response.id, response.model, response.created);\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.prompt_tokens,\n      response.usage.completion_tokens,\n      response.usage.total_tokens,\n    );\n  }\n  if (Array.isArray(response.choices)) {\n    const finishReasons = response.choices\n      .map(choice => choice.finish_reason)\n      .filter((reason): reason is string => reason !== null);\n    if (finishReasons.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(finishReasons),\n      });\n    }\n\n    // Extract tool calls from all choices (only if recordOutputs is true)\n    if (recordOutputs) {\n      const toolCalls = response.choices\n        .map(choice => choice.message?.tool_calls)\n        .filter(calls => Array.isArray(calls) && calls.length > 0)\n        .flat();\n\n      if (toolCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls),\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add attributes for Responses API responses\n */\nfunction addResponsesApiAttributes(span: Span, response: OpenAIResponseObject, recordOutputs?: boolean): void {\n  setCommonResponseAttributes(span, response.id, response.model, response.created_at);\n  if (response.status) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify([response.status]),\n    });\n  }\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.input_tokens,\n      response.usage.output_tokens,\n      response.usage.total_tokens,\n    );\n  }\n\n  // Extract function calls from output (only if recordOutputs is true)\n  if (recordOutputs) {\n    const responseWithOutput = response as OpenAIResponseObject & { output?: unknown[] };\n    if (Array.isArray(responseWithOutput.output) && responseWithOutput.output.length > 0) {\n      // Filter for function_call type objects in the output array\n      const functionCalls = responseWithOutput.output.filter(\n        (item): unknown =>\n          typeof item === 'object' && item !== null && (item as Record<string, unknown>).type === 'function_call',\n      );\n\n      if (functionCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(functionCalls),\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add response attributes to spans\n * This currently supports both Chat Completion and Responses API responses\n */\nfunction addResponseAttributes(span: Span, result: unknown, recordOutputs?: boolean): void {\n  if (!result || typeof result !== 'object') return;\n\n  const response = result as OpenAiResponse;\n\n  if (isChatCompletionResponse(response)) {\n    addChatCompletionAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.choices?.length) {\n      const responseTexts = response.choices.map(choice => choice.message?.content || '');\n      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(responseTexts) });\n    }\n  } else if (isResponsesApiResponse(response)) {\n    addResponsesApiAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.output_text) {\n      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.output_text });\n    }\n  }\n}\n\n// Extract and record AI request inputs, if present. This is intentionally separate from response attributes.\nfunction addRequestAttributes(span: Span, params: Record<string, unknown>): void {\n  if ('messages' in params) {\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.messages) });\n  }\n  if ('input' in params) {\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.input) });\n  }\n}\n\nfunction getOptionsFromIntegration(): OpenAiOptions {\n  const scope = getCurrentScope();\n  const client = scope.getClient();\n  const integration = client?.getIntegrationByName(OPENAI_INTEGRATION_NAME) as OpenAiIntegration | undefined;\n  const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n\n  return {\n    recordInputs: integration?.options?.recordInputs ?? shouldRecordInputsAndOutputs,\n    recordOutputs: integration?.options?.recordOutputs ?? shouldRecordInputsAndOutputs,\n  };\n}\n\n/**\n * Instrument a method with Sentry spans\n * Following Sentry AI Agents Manual Instrumentation conventions\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod<T extends unknown[], R>(\n  originalMethod: (...args: T) => Promise<R>,\n  methodPath: InstrumentedMethod,\n  context: unknown,\n  options?: OpenAiOptions,\n): (...args: T) => Promise<R> {\n  return async function instrumentedMethod(...args: T): Promise<R> {\n    const finalOptions = options || getOptionsFromIntegration();\n    const requestAttributes = extractRequestAttributes(args, methodPath);\n    const model = (requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] as string) || 'unknown';\n    const operationName = getOperationName(methodPath);\n\n    const params = args[0] as Record<string, unknown> | undefined;\n    const isStreamRequested = params && typeof params === 'object' && params.stream === true;\n\n    if (isStreamRequested) {\n      // For streaming responses, use manual span management to properly handle the async generator lifecycle\n      return startSpanManual(\n        {\n          name: `${operationName} ${model} stream-response`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes as Record<string, SpanAttributeValue>,\n        },\n        async (span: Span) => {\n          try {\n            if (finalOptions.recordInputs && args[0] && typeof args[0] === 'object') {\n              addRequestAttributes(span, args[0] as Record<string, unknown>);\n            }\n\n            const result = await originalMethod.apply(context, args);\n\n            return instrumentStream(\n              result as OpenAIStream<ChatCompletionChunk | ResponseStreamingEvent>,\n              span,\n              finalOptions.recordOutputs ?? false,\n            ) as unknown as R;\n          } catch (error) {\n            // For streaming requests that fail before stream creation, we still want to record\n            // them as streaming requests but end the span gracefully\n            span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n            captureException(error, {\n              mechanism: {\n                handled: false,\n              },\n            });\n            span.end();\n            throw error;\n          }\n        },\n      );\n    } else {\n      //  Non-streaming responses\n      return startSpan(\n        {\n          name: `${operationName} ${model}`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes as Record<string, SpanAttributeValue>,\n        },\n        async (span: Span) => {\n          try {\n            if (finalOptions.recordInputs && args[0] && typeof args[0] === 'object') {\n              addRequestAttributes(span, args[0] as Record<string, unknown>);\n            }\n\n            const result = await originalMethod.apply(context, args);\n            addResponseAttributes(span, result, finalOptions.recordOutputs);\n            return result;\n          } catch (error) {\n            captureException(error);\n            throw error;\n          }\n        },\n      );\n    }\n  };\n}\n\n/**\n * Create a deep proxy for OpenAI client instrumentation\n */\nfunction createDeepProxy(target: object, currentPath = '', options?: OpenAiOptions): OpenAiClient {\n  return new Proxy(target, {\n    get(obj: object, prop: string): unknown {\n      const value = (obj as Record<string, unknown>)[prop];\n      const methodPath = buildMethodPath(currentPath, String(prop));\n\n      if (typeof value === 'function' && shouldInstrument(methodPath)) {\n        return instrumentMethod(value as (...args: unknown[]) => Promise<unknown>, methodPath, obj, options);\n      }\n\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context,\n        // which is required for accessing private class fields (e.g. #baseURL) in OpenAI SDK v5.\n        return value.bind(obj);\n      }\n\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value as object, methodPath, options);\n      }\n\n      return value;\n    },\n  });\n}\n\n/**\n * Instrument an OpenAI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n */\nexport function instrumentOpenAiClient(client: OpenAiClient, options?: OpenAiOptions): OpenAiClient {\n  return createDeepProxy(client, '', options);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}