{"ast":null,"code":"import { addBreadcrumb } from '../breadcrumbs.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { captureException } from '../exports.js';\nimport { defineIntegration } from '../integration.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { isPlainObject } from '../utils/is.js';\nimport { SPAN_STATUS_ERROR, SPAN_STATUS_OK, setHttpStatus } from '../tracing/spanstatus.js';\nimport { startSpan } from '../tracing/trace.js';\n\n// Based on Kamil OgÃ³rek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = ['reauthenticate', 'signInAnonymously', 'signInWithOAuth', 'signInWithIdToken', 'signInWithOtp', 'signInWithPassword', 'signInWithSSO', 'signOut', 'signUp', 'verifyOtp'];\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = ['createUser', 'deleteUser', 'listUsers', 'getUserById', 'updateUserById', 'inviteUserByEmail'];\nconst FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not'\n};\nconst DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\nfunction markAsInstrumented(fn) {\n  try {\n    fn.__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\nfunction isInstrumented(fn) {\n  try {\n    return fn.__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nfunction extractOperation(method) {\n  let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (method) {\n    case 'GET':\n      {\n        return 'select';\n      }\n    case 'POST':\n      {\n        if (headers['Prefer']?.includes('resolution=')) {\n          return 'upsert';\n        } else {\n          return 'insert';\n        }\n      }\n    case 'PATCH':\n      {\n        return 'update';\n      }\n    case 'DELETE':\n      {\n        return 'delete';\n      }\n    default:\n      {\n        return '<unknown-op>';\n      }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nfunction translateFiltersIntoMethods(key, query) {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n  const [filter, ...value] = query.split('.');\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = filter && FILTER_MAPPINGS[filter] || 'filter';\n  }\n  return `${method}(${key}, ${value.join('.')})`;\n}\nfunction instrumentAuthOperation(operation) {\n  let isAdmin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return startSpan({\n        name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n          'db.system': 'postgresql',\n          'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`\n        }\n      }, span => {\n        return Reflect.apply(target, thisArg, argumentsList).then(res => {\n          if (res && typeof res === 'object' && 'error' in res && res.error) {\n            span.setStatus({\n              code: SPAN_STATUS_ERROR\n            });\n            captureException(res.error, {\n              mechanism: {\n                handled: false\n              }\n            });\n          } else {\n            span.setStatus({\n              code: SPAN_STATUS_OK\n            });\n          }\n          span.end();\n          return res;\n        }).catch(err => {\n          span.setStatus({\n            code: SPAN_STATUS_ERROR\n          });\n          span.end();\n          captureException(err, {\n            mechanism: {\n              handled: false\n            }\n          });\n          throw err;\n        }).then(...argumentsList);\n      });\n    }\n  });\n}\nfunction instrumentSupabaseAuthClient(supabaseClientInstance) {\n  const auth = supabaseClientInstance.auth;\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n    if (!authOperation) {\n      continue;\n    }\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n    if (!authOperation) {\n      continue;\n    }\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n  markAsInstrumented(supabaseClientInstance.auth);\n}\nfunction instrumentSupabaseClientConstructor(SupabaseClient) {\n  if (isInstrumented(SupabaseClient.prototype.from)) {\n    return;\n  }\n  SupabaseClient.prototype.from = new Proxy(SupabaseClient.prototype.from, {\n    apply(target, thisArg, argumentsList) {\n      const rv = Reflect.apply(target, thisArg, argumentsList);\n      const PostgRESTQueryBuilder = rv.constructor;\n      instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder);\n      return rv;\n    }\n  });\n  markAsInstrumented(SupabaseClient.prototype.from);\n}\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder) {\n  if (isInstrumented(PostgRESTFilterBuilder.prototype.then)) {\n    return;\n  }\n  PostgRESTFilterBuilder.prototype.then = new Proxy(PostgRESTFilterBuilder.prototype.then, {\n    apply(target, thisArg, argumentsList) {\n      const operations = DB_OPERATIONS_TO_INSTRUMENT;\n      const typedThis = thisArg;\n      const operation = extractOperation(typedThis.method, typedThis.headers);\n      if (!operations.includes(operation)) {\n        return Reflect.apply(target, thisArg, argumentsList);\n      }\n      if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n        return Reflect.apply(target, thisArg, argumentsList);\n      }\n      const pathParts = typedThis.url.pathname.split('/');\n      const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n      const queryItems = [];\n      for (const [key, value] of typedThis.url.searchParams.entries()) {\n        // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n        // so we need to use array instead of object to collect them.\n        queryItems.push(translateFiltersIntoMethods(key, value));\n      }\n      const body = Object.create(null);\n      if (isPlainObject(typedThis.body)) {\n        for (const [key, value] of Object.entries(typedThis.body)) {\n          body[key] = value;\n        }\n      }\n\n      // Adding operation to the beginning of the description if it's not a `select` operation\n      // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n      // For `select` operations, we don't need repeat it in the description\n      const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(' ')} from(${table})`;\n      const attributes = {\n        'db.table': table,\n        'db.schema': typedThis.schema,\n        'db.url': typedThis.url.origin,\n        'db.sdk': typedThis.headers['X-Client-Info'],\n        'db.system': 'postgresql',\n        'db.operation': operation,\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db'\n      };\n      if (queryItems.length) {\n        attributes['db.query'] = queryItems;\n      }\n      if (Object.keys(body).length) {\n        attributes['db.body'] = body;\n      }\n      return startSpan({\n        name: description,\n        attributes\n      }, span => {\n        return Reflect.apply(target, thisArg, []).then(res => {\n          if (span) {\n            if (res && typeof res === 'object' && 'status' in res) {\n              setHttpStatus(span, res.status || 500);\n            }\n            span.end();\n          }\n          if (res.error) {\n            const err = new Error(res.error.message);\n            if (res.error.code) {\n              err.code = res.error.code;\n            }\n            if (res.error.details) {\n              err.details = res.error.details;\n            }\n            const supabaseContext = {};\n            if (queryItems.length) {\n              supabaseContext.query = queryItems;\n            }\n            if (Object.keys(body).length) {\n              supabaseContext.body = body;\n            }\n            captureException(err, {\n              contexts: {\n                supabase: supabaseContext\n              }\n            });\n          }\n          const breadcrumb = {\n            type: 'supabase',\n            category: `db.${operation}`,\n            message: description\n          };\n          const data = {};\n          if (queryItems.length) {\n            data.query = queryItems;\n          }\n          if (Object.keys(body).length) {\n            data.body = body;\n          }\n          if (Object.keys(data).length) {\n            breadcrumb.data = data;\n          }\n          addBreadcrumb(breadcrumb);\n          return res;\n        }, err => {\n          if (span) {\n            setHttpStatus(span, 500);\n            span.end();\n          }\n          throw err;\n        }).then(...argumentsList);\n      });\n    }\n  });\n  markAsInstrumented(PostgRESTFilterBuilder.prototype.then);\n}\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder) {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented(PostgRESTQueryBuilder.prototype[operation])) {\n      continue;\n    }\n    PostgRESTQueryBuilder.prototype[operation] = new Proxy(PostgRESTQueryBuilder.prototype[operation], {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTFilterBuilder = rv.constructor;\n        DEBUG_BUILD && debug.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n        instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n        return rv;\n      }\n    });\n    markAsInstrumented(PostgRESTQueryBuilder.prototype[operation]);\n  }\n}\nconst instrumentSupabaseClient = supabaseClient => {\n  if (!supabaseClient) {\n    DEBUG_BUILD && debug.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor = supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient);\n};\nconst INTEGRATION_NAME = 'Supabase';\nconst _supabaseIntegration = supabaseClient => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME\n  };\n};\nconst supabaseIntegration = defineIntegration(options => {\n  return _supabaseIntegration(options.supabaseClient);\n});\nexport { DB_OPERATIONS_TO_INSTRUMENT, FILTER_MAPPINGS, extractOperation, instrumentSupabaseClient, supabaseIntegration, translateFiltersIntoMethods };","map":{"version":3,"names":["AUTH_OPERATIONS_TO_INSTRUMENT","AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT","FILTER_MAPPINGS","eq","neq","gt","gte","lt","lte","like","ilike","is","in","cs","cd","sr","nxl","sl","nxr","adj","ov","fts","plfts","phfts","wfts","not","DB_OPERATIONS_TO_INSTRUMENT","markAsInstrumented","fn","__SENTRY_INSTRUMENTED__","isInstrumented","extractOperation","method","headers","arguments","length","undefined","includes","translateFiltersIntoMethods","key","query","endsWith","filter","value","split","startsWith","join","instrumentAuthOperation","operation","isAdmin","Proxy","apply","target","thisArg","argumentsList","startSpan","name","attributes","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","span","Reflect","then","res","error","setStatus","code","SPAN_STATUS_ERROR","captureException","mechanism","handled","SPAN_STATUS_OK","end","catch","err","instrumentSupabaseAuthClient","supabaseClientInstance","auth","authOperation","admin","instrumentSupabaseClientConstructor","SupabaseClient","prototype","from","rv","PostgRESTQueryBuilder","constructor","instrumentPostgRESTQueryBuilder","instrumentPostgRESTFilterBuilder","PostgRESTFilterBuilder","operations","typedThis","url","pathname","pathParts","table","queryItems","searchParams","entries","push","body","Object","create","isPlainObject","description","schema","origin","keys","setHttpStatus","status","Error","message","details","supabaseContext","contexts","supabase","breadcrumb","type","category","data","addBreadcrumb","DEBUG_BUILD","debug","log","instrumentSupabaseClient","supabaseClient","warn","SupabaseClientConstructor","Function","INTEGRATION_NAME","_supabaseIntegration","setupOnce","supabaseIntegration","defineIntegration","options"],"sources":["/workspace/node_modules/@sentry/core/src/integrations/supabase.ts"],"sourcesContent":["// Based on Kamil OgÃ³rek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\n/* eslint-disable max-lines */\nimport { addBreadcrumb } from '../breadcrumbs';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { captureException } from '../exports';\nimport { defineIntegration } from '../integration';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes';\nimport { setHttpStatus, SPAN_STATUS_ERROR, SPAN_STATUS_OK, startSpan } from '../tracing';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { debug } from '../utils/debug-logger';\nimport { isPlainObject } from '../utils/is';\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = [\n  'reauthenticate',\n  'signInAnonymously',\n  'signInWithOAuth',\n  'signInWithIdToken',\n  'signInWithOtp',\n  'signInWithPassword',\n  'signInWithSSO',\n  'signOut',\n  'signUp',\n  'verifyOtp',\n];\n\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = [\n  'createUser',\n  'deleteUser',\n  'listUsers',\n  'getUserById',\n  'updateUserById',\n  'inviteUserByEmail',\n];\n\nexport const FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not',\n};\n\nexport const DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\n\ntype AuthOperationFn = (...args: unknown[]) => Promise<unknown>;\ntype AuthOperationName = (typeof AUTH_OPERATIONS_TO_INSTRUMENT)[number];\ntype AuthAdminOperationName = (typeof AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT)[number];\ntype PostgRESTQueryOperationFn = (...args: unknown[]) => PostgRESTFilterBuilder;\n\nexport interface SupabaseClientInstance {\n  auth: {\n    admin: Record<AuthAdminOperationName, AuthOperationFn>;\n  } & Record<AuthOperationName, AuthOperationFn>;\n}\n\nexport interface PostgRESTQueryBuilder {\n  [key: string]: PostgRESTQueryOperationFn;\n}\n\nexport interface PostgRESTFilterBuilder {\n  method: string;\n  headers: Record<string, string>;\n  url: URL;\n  schema: string;\n  body: any;\n}\n\nexport interface SupabaseResponse {\n  status?: number;\n  error?: {\n    message: string;\n    code?: string;\n    details?: unknown;\n  };\n}\n\nexport interface SupabaseError extends Error {\n  code?: string;\n  details?: unknown;\n}\n\nexport interface SupabaseBreadcrumb {\n  type: string;\n  category: string;\n  message: string;\n  data?: {\n    query?: string[];\n    body?: Record<string, unknown>;\n  };\n}\n\nexport interface SupabaseClientConstructor {\n  prototype: {\n    from: (table: string) => PostgRESTQueryBuilder;\n  };\n}\n\nexport interface PostgRESTProtoThenable {\n  then: <T>(\n    onfulfilled?: ((value: T) => T | PromiseLike<T>) | null,\n    onrejected?: ((reason: any) => T | PromiseLike<T>) | null,\n  ) => Promise<T>;\n}\n\ntype SentryInstrumented<T> = T & {\n  __SENTRY_INSTRUMENTED__?: boolean;\n};\n\nfunction markAsInstrumented<T>(fn: T): void {\n  try {\n    (fn as SentryInstrumented<T>).__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\n\nfunction isInstrumented<T>(fn: T): boolean | undefined {\n  try {\n    return (fn as SentryInstrumented<T>).__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nexport function extractOperation(method: string, headers: Record<string, string> = {}): string {\n  switch (method) {\n    case 'GET': {\n      return 'select';\n    }\n    case 'POST': {\n      if (headers['Prefer']?.includes('resolution=')) {\n        return 'upsert';\n      } else {\n        return 'insert';\n      }\n    }\n    case 'PATCH': {\n      return 'update';\n    }\n    case 'DELETE': {\n      return 'delete';\n    }\n    default: {\n      return '<unknown-op>';\n    }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nexport function translateFiltersIntoMethods(key: string, query: string): string {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n\n  const [filter, ...value] = query.split('.');\n\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = (filter && FILTER_MAPPINGS[filter as keyof typeof FILTER_MAPPINGS]) || 'filter';\n  }\n\n  return `${method}(${key}, ${value.join('.')})`;\n}\n\nfunction instrumentAuthOperation(operation: AuthOperationFn, isAdmin = false): AuthOperationFn {\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return startSpan(\n        {\n          name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n            'db.system': 'postgresql',\n            'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`,\n          },\n        },\n        span => {\n          return Reflect.apply(target, thisArg, argumentsList)\n            .then((res: unknown) => {\n              if (res && typeof res === 'object' && 'error' in res && res.error) {\n                span.setStatus({ code: SPAN_STATUS_ERROR });\n\n                captureException(res.error, {\n                  mechanism: {\n                    handled: false,\n                  },\n                });\n              } else {\n                span.setStatus({ code: SPAN_STATUS_OK });\n              }\n\n              span.end();\n              return res;\n            })\n            .catch((err: unknown) => {\n              span.setStatus({ code: SPAN_STATUS_ERROR });\n              span.end();\n\n              captureException(err, {\n                mechanism: {\n                  handled: false,\n                },\n              });\n\n              throw err;\n            })\n            .then(...argumentsList);\n        },\n      );\n    },\n  });\n}\n\nfunction instrumentSupabaseAuthClient(supabaseClientInstance: SupabaseClientInstance): void {\n  const auth = supabaseClientInstance.auth;\n\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n\n  markAsInstrumented(supabaseClientInstance.auth);\n}\n\nfunction instrumentSupabaseClientConstructor(SupabaseClient: unknown): void {\n  if (isInstrumented((SupabaseClient as unknown as SupabaseClientConstructor).prototype.from)) {\n    return;\n  }\n\n  (SupabaseClient as unknown as SupabaseClientConstructor).prototype.from = new Proxy(\n    (SupabaseClient as unknown as SupabaseClientConstructor).prototype.from,\n    {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTQueryBuilder = (rv as PostgRESTQueryBuilder).constructor;\n\n        instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder as unknown as new () => PostgRESTQueryBuilder);\n\n        return rv;\n      },\n    },\n  );\n\n  markAsInstrumented((SupabaseClient as unknown as SupabaseClientConstructor).prototype.from);\n}\n\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder: PostgRESTFilterBuilder['constructor']): void {\n  if (isInstrumented((PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then)) {\n    return;\n  }\n\n  (PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then = new Proxy(\n    (PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then,\n    {\n      apply(target, thisArg, argumentsList) {\n        const operations = DB_OPERATIONS_TO_INSTRUMENT;\n        const typedThis = thisArg as PostgRESTFilterBuilder;\n        const operation = extractOperation(typedThis.method, typedThis.headers);\n\n        if (!operations.includes(operation)) {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        const pathParts = typedThis.url.pathname.split('/');\n        const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n\n        const queryItems: string[] = [];\n        for (const [key, value] of typedThis.url.searchParams.entries()) {\n          // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n          // so we need to use array instead of object to collect them.\n          queryItems.push(translateFiltersIntoMethods(key, value));\n        }\n        const body: Record<string, unknown> = Object.create(null);\n        if (isPlainObject(typedThis.body)) {\n          for (const [key, value] of Object.entries(typedThis.body)) {\n            body[key] = value;\n          }\n        }\n\n        // Adding operation to the beginning of the description if it's not a `select` operation\n        // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n        // For `select` operations, we don't need repeat it in the description\n        const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(\n          ' ',\n        )} from(${table})`;\n\n        const attributes: Record<string, any> = {\n          'db.table': table,\n          'db.schema': typedThis.schema,\n          'db.url': typedThis.url.origin,\n          'db.sdk': typedThis.headers['X-Client-Info'],\n          'db.system': 'postgresql',\n          'db.operation': operation,\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n        };\n\n        if (queryItems.length) {\n          attributes['db.query'] = queryItems;\n        }\n\n        if (Object.keys(body).length) {\n          attributes['db.body'] = body;\n        }\n\n        return startSpan(\n          {\n            name: description,\n            attributes,\n          },\n          span => {\n            return (Reflect.apply(target, thisArg, []) as Promise<SupabaseResponse>)\n              .then(\n                (res: SupabaseResponse) => {\n                  if (span) {\n                    if (res && typeof res === 'object' && 'status' in res) {\n                      setHttpStatus(span, res.status || 500);\n                    }\n                    span.end();\n                  }\n\n                  if (res.error) {\n                    const err = new Error(res.error.message) as SupabaseError;\n                    if (res.error.code) {\n                      err.code = res.error.code;\n                    }\n                    if (res.error.details) {\n                      err.details = res.error.details;\n                    }\n\n                    const supabaseContext: Record<string, unknown> = {};\n                    if (queryItems.length) {\n                      supabaseContext.query = queryItems;\n                    }\n                    if (Object.keys(body).length) {\n                      supabaseContext.body = body;\n                    }\n\n                    captureException(err, {\n                      contexts: {\n                        supabase: supabaseContext,\n                      },\n                    });\n                  }\n\n                  const breadcrumb: SupabaseBreadcrumb = {\n                    type: 'supabase',\n                    category: `db.${operation}`,\n                    message: description,\n                  };\n\n                  const data: Record<string, unknown> = {};\n\n                  if (queryItems.length) {\n                    data.query = queryItems;\n                  }\n\n                  if (Object.keys(body).length) {\n                    data.body = body;\n                  }\n\n                  if (Object.keys(data).length) {\n                    breadcrumb.data = data;\n                  }\n\n                  addBreadcrumb(breadcrumb);\n\n                  return res;\n                },\n                (err: Error) => {\n                  if (span) {\n                    setHttpStatus(span, 500);\n                    span.end();\n                  }\n                  throw err;\n                },\n              )\n              .then(...argumentsList);\n          },\n        );\n      },\n    },\n  );\n\n  markAsInstrumented((PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then);\n}\n\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder: new () => PostgRESTQueryBuilder): void {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented((PostgRESTQueryBuilder.prototype as Record<string, any>)[operation])) {\n      continue;\n    }\n\n    type PostgRESTOperation = keyof Pick<PostgRESTQueryBuilder, 'select' | 'insert' | 'upsert' | 'update' | 'delete'>;\n    (PostgRESTQueryBuilder.prototype as Record<string, any>)[operation as PostgRESTOperation] = new Proxy(\n      (PostgRESTQueryBuilder.prototype as Record<string, any>)[operation as PostgRESTOperation],\n      {\n        apply(target, thisArg, argumentsList) {\n          const rv = Reflect.apply(target, thisArg, argumentsList);\n          const PostgRESTFilterBuilder = (rv as PostgRESTFilterBuilder).constructor;\n\n          DEBUG_BUILD && debug.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n\n          instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n\n          return rv;\n        },\n      },\n    );\n\n    markAsInstrumented((PostgRESTQueryBuilder.prototype as Record<string, any>)[operation]);\n  }\n}\n\nexport const instrumentSupabaseClient = (supabaseClient: unknown): void => {\n  if (!supabaseClient) {\n    DEBUG_BUILD && debug.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor =\n    supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient as SupabaseClientInstance);\n};\n\nconst INTEGRATION_NAME = 'Supabase';\n\nconst _supabaseIntegration = ((supabaseClient: unknown) => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME,\n  };\n}) satisfies IntegrationFn;\n\nexport const supabaseIntegration = defineIntegration((options: { supabaseClient: any }) => {\n  return _supabaseIntegration(options.supabaseClient);\n}) satisfies IntegrationFn;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}