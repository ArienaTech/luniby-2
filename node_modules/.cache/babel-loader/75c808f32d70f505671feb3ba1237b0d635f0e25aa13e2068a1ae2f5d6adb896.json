{"ast":null,"code":"import { getClient, getCurrentScope } from '../currentScopes.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '../semanticAttributes.js';\nimport { debug } from '../utils/debug-logger.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { _setSpanForScope } from '../utils/spanOnScope.js';\nimport { getActiveSpan, spanTimeInputToSeconds, getSpanDescendants, spanToJSON, removeChildSpanFromSpan } from '../utils/spanUtils.js';\nimport { timestampInSeconds } from '../utils/time.js';\nimport { getDynamicSamplingContextFromSpan, freezeDscOnSpan } from './dynamicSamplingContext.js';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan.js';\nimport { SentrySpan } from './sentrySpan.js';\nimport { SPAN_STATUS_ERROR } from './spanstatus.js';\nimport { startInactiveSpan } from './trace.js';\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  childSpanTimeout: 15000\n};\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nfunction startIdleSpan(startSpanOptions) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Activities store a list of active spans\n  const activities = new Map();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID;\n\n  // The reason why the span was finished\n  let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n  let _autoFinishAllowed = !options.disableAutoFinish;\n  const _cleanupHooks = [];\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd\n  } = options;\n  const client = getClient();\n  if (!client || !hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...getDynamicSamplingContextFromSpan(span)\n    };\n    freezeDscOnSpan(span, dsc);\n    return span;\n  }\n  const scope = getCurrentScope();\n  const previousActiveSpan = getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || timestampInSeconds();\n      const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n      const childEndTimestamps = spans.map(span => spanToJSON(span).timestamp).filter(timestamp => !!timestamp);\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity, Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)));\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    }\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout() {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp) {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp) {\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId) {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n    const endTimestamp = timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId) {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n    if (activities.size === 0) {\n      const endTimestamp = timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n    }\n  }\n  function onIdleSpanEnded(endTimestamp) {\n    _finished = true;\n    activities.clear();\n    _cleanupHooks.forEach(cleanup => cleanup());\n    _setSpanForScope(scope, previousActiveSpan);\n    const spanJSON = spanToJSON(span);\n    const {\n      start_timestamp: startTimestamp\n    } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n    const attributes = spanJSON.data;\n    if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n    debug.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n    const childSpans = getSpanDescendants(span).filter(child => child !== span);\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({\n          code: SPAN_STATUS_ERROR,\n          message: 'cancelled'\n        });\n        childSpan.end(endTimestamp);\n        DEBUG_BUILD && debug.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n      const childSpanJSON = spanToJSON(childSpan);\n      const {\n        timestamp: childEndTimestamp = 0,\n        start_timestamp: childStartTimestamp = 0\n      } = childSpanJSON;\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n      if (DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          debug.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          debug.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n  _cleanupHooks.push(client.on('spanStart', startedSpan => {\n    // If we already finished the idle span,\n    // or if this is the idle span itself being started,\n    // or if the started span has already been closed,\n    // we don't care about it for activity\n    if (_finished || startedSpan === span || !!spanToJSON(startedSpan).timestamp || startedSpan instanceof SentrySpan && startedSpan.isStandaloneSpan()) {\n      return;\n    }\n    const allSpans = getSpanDescendants(span);\n\n    // If the span that was just started is a child of the idle span, we should track it\n    if (allSpans.includes(startedSpan)) {\n      _pushActivity(startedSpan.spanContext().spanId);\n    }\n  }));\n  _cleanupHooks.push(client.on('spanEnd', endedSpan => {\n    if (_finished) {\n      return;\n    }\n    _popActivity(endedSpan.spanContext().spanId);\n  }));\n  _cleanupHooks.push(client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n    if (spanToAllowAutoFinish === span) {\n      _autoFinishAllowed = true;\n      _restartIdleTimeout();\n      if (activities.size) {\n        _restartChildSpanTimeout();\n      }\n    }\n  }));\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({\n        code: SPAN_STATUS_ERROR,\n        message: 'deadline_exceeded'\n      });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n  return span;\n}\nfunction _startIdleSpan(options) {\n  const span = startInactiveSpan(options);\n  _setSpanForScope(getCurrentScope(), span);\n  DEBUG_BUILD && debug.log('[Tracing] Started span is an idle span');\n  return span;\n}\nexport { TRACING_DEFAULTS, startIdleSpan };","map":{"version":3,"names":["TRACING_DEFAULTS","idleTimeout","finalTimeout","childSpanTimeout","FINISH_REASON_HEARTBEAT_FAILED","FINISH_REASON_IDLE_TIMEOUT","FINISH_REASON_FINAL_TIMEOUT","FINISH_REASON_EXTERNAL_FINISH","startIdleSpan","startSpanOptions","options","arguments","length","undefined","activities","Map","_finished","_idleTimeoutID","_finishReason","_autoFinishAllowed","disableAutoFinish","_cleanupHooks","beforeSpanEnd","client","getClient","hasSpansEnabled","span","SentryNonRecordingSpan","dsc","sample_rate","sampled","getDynamicSamplingContextFromSpan","freezeDscOnSpan","scope","getCurrentScope","previousActiveSpan","getActiveSpan","_startIdleSpan","end","Proxy","apply","target","thisArg","args","definedEndTimestamp","rest","timestamp","timestampInSeconds","spanEndTimestamp","spanTimeInputToSeconds","spans","getSpanDescendants","filter","child","onIdleSpanEnded","Reflect","childEndTimestamps","map","spanToJSON","latestSpanEndTimestamp","Math","max","spanStartTimestamp","start_timestamp","endTimestamp","min","Infinity","_cancelIdleTimeout","clearTimeout","_restartIdleTimeout","setTimeout","size","_restartChildSpanTimeout","_pushActivity","spanId","set","_popActivity","has","delete","clear","forEach","cleanup","_setSpanForScope","spanJSON","startTimestamp","attributes","data","SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON","setAttribute","debug","log","op","childSpans","discardedSpans","childSpan","isRecording","setStatus","code","SPAN_STATUS_ERROR","message","DEBUG_BUILD","JSON","stringify","childSpanJSON","childEndTimestamp","childStartTimestamp","spanStartedBeforeIdleSpanEnd","timeoutWithMarginOfError","spanEndedBeforeFinalTimeout","stringifiedSpan","removeChildSpanFromSpan","push","on","startedSpan","SentrySpan","isStandaloneSpan","allSpans","includes","spanContext","endedSpan","spanToAllowAutoFinish","startInactiveSpan"],"sources":["/workspace/node_modules/@sentry/core/src/tracing/idleSpan.ts"],"sourcesContent":["import { getClient, getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON } from '../semanticAttributes';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport type { Span } from '../types-hoist/span';\nimport type { StartSpanOptions } from '../types-hoist/startSpanOptions';\nimport { debug } from '../utils/debug-logger';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled';\nimport { _setSpanForScope } from '../utils/spanOnScope';\nimport {\n  getActiveSpan,\n  getSpanDescendants,\n  removeChildSpanFromSpan,\n  spanTimeInputToSeconds,\n  spanToJSON,\n} from '../utils/spanUtils';\nimport { timestampInSeconds } from '../utils/time';\nimport { freezeDscOnSpan, getDynamicSamplingContextFromSpan } from './dynamicSamplingContext';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan';\nimport { SentrySpan } from './sentrySpan';\nimport { SPAN_STATUS_ERROR } from './spanstatus';\nimport { startInactiveSpan } from './trace';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1_000,\n  finalTimeout: 30_000,\n  childSpanTimeout: 15_000,\n};\n\nconst FINISH_REASON_HEARTBEAT_FAILED = 'heartbeatFailed';\nconst FINISH_REASON_IDLE_TIMEOUT = 'idleTimeout';\nconst FINISH_REASON_FINAL_TIMEOUT = 'finalTimeout';\nconst FINISH_REASON_EXTERNAL_FINISH = 'externalFinish';\nconst FINISH_REASON_CANCELLED = 'cancelled';\n\n// unused\nconst FINISH_REASON_DOCUMENT_HIDDEN = 'documentHidden';\n\n// unused in this file, but used in BrowserTracing\nconst FINISH_REASON_INTERRUPTED = 'interactionInterrupted';\n\ntype IdleSpanFinishReason =\n  | typeof FINISH_REASON_CANCELLED\n  | typeof FINISH_REASON_DOCUMENT_HIDDEN\n  | typeof FINISH_REASON_EXTERNAL_FINISH\n  | typeof FINISH_REASON_FINAL_TIMEOUT\n  | typeof FINISH_REASON_HEARTBEAT_FAILED\n  | typeof FINISH_REASON_IDLE_TIMEOUT\n  | typeof FINISH_REASON_INTERRUPTED;\n\ninterface IdleSpanOptions {\n  /**\n   * The time that has to pass without any span being created.\n   * If this time is exceeded, the idle span will finish.\n   */\n  idleTimeout: number;\n  /**\n   * The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   */\n  finalTimeout: number;\n  /**\n   * The max. time a child span may run.\n   * If the time since the last span was started exceeds this time, the idle span will finish.\n   */\n  childSpanTimeout?: number;\n  /**\n   * When set to `true`, will disable the idle timeout and child timeout\n   * until the `idleSpanEnableAutoFinish` hook is emitted for the idle span.\n   * The final timeout mechanism will not be affected by this option,\n   * meaning the idle span will definitely be finished when the final timeout is\n   * reached, no matter what this option is configured to.\n   *\n   * Defaults to `false`.\n   */\n  disableAutoFinish?: boolean;\n  /** Allows to configure a hook that is called when the idle span is ended, before it is processed. */\n  beforeSpanEnd?: (span: Span) => void;\n}\n\n/**\n * An idle span is a span that automatically finishes. It does this by tracking child spans as activities.\n * An idle span is always the active span.\n */\nexport function startIdleSpan(startSpanOptions: StartSpanOptions, options: Partial<IdleSpanOptions> = {}): Span {\n  // Activities store a list of active spans\n  const activities = new Map<string, boolean>();\n\n  // We should not use heartbeat if we finished a span\n  let _finished = false;\n\n  // Timer that tracks idleTimeout\n  let _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  // Timer that tracks maxSpanTime for child spans\n  let _childSpanTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  // The reason why the span was finished\n  let _finishReason: IdleSpanFinishReason = FINISH_REASON_EXTERNAL_FINISH;\n\n  let _autoFinishAllowed: boolean = !options.disableAutoFinish;\n\n  const _cleanupHooks: (() => void)[] = [];\n\n  const {\n    idleTimeout = TRACING_DEFAULTS.idleTimeout,\n    finalTimeout = TRACING_DEFAULTS.finalTimeout,\n    childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n    beforeSpanEnd,\n  } = options;\n\n  const client = getClient();\n\n  if (!client || !hasSpansEnabled()) {\n    const span = new SentryNonRecordingSpan();\n\n    const dsc = {\n      sample_rate: '0',\n      sampled: 'false',\n      ...getDynamicSamplingContextFromSpan(span),\n    } satisfies Partial<DynamicSamplingContext>;\n    freezeDscOnSpan(span, dsc);\n\n    return span;\n  }\n\n  const scope = getCurrentScope();\n  const previousActiveSpan = getActiveSpan();\n  const span = _startIdleSpan(startSpanOptions);\n\n  // We patch span.end to ensure we can run some things before the span is ended\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args: Parameters<Span['end']>) {\n      if (beforeSpanEnd) {\n        beforeSpanEnd(span);\n      }\n\n      // If the span is non-recording, nothing more to do here...\n      // This is the case if tracing is enabled but this specific span was not sampled\n      if (thisArg instanceof SentryNonRecordingSpan) {\n        return;\n      }\n\n      // Just ensuring that this keeps working, even if we ever have more arguments here\n      const [definedEndTimestamp, ...rest] = args;\n      const timestamp = definedEndTimestamp || timestampInSeconds();\n      const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n\n      // Ensure we end with the last span timestamp, if possible\n      const spans = getSpanDescendants(span).filter(child => child !== span);\n\n      // If we have no spans, we just end, nothing else to do here\n      if (!spans.length) {\n        onIdleSpanEnded(spanEndTimestamp);\n        return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n      }\n\n      const childEndTimestamps = spans\n        .map(span => spanToJSON(span).timestamp)\n        .filter(timestamp => !!timestamp) as number[];\n      const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : undefined;\n\n      // In reality this should always exist here, but type-wise it may be undefined...\n      const spanStartTimestamp = spanToJSON(span).start_timestamp;\n\n      // The final endTimestamp should:\n      // * Never be before the span start timestamp\n      // * Be the latestSpanEndTimestamp, if there is one, and it is smaller than the passed span end timestamp\n      // * Otherwise be the passed end timestamp\n      // Final timestamp can never be after finalTimeout\n      const endTimestamp = Math.min(\n        spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1000 : Infinity,\n        Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity)),\n      );\n\n      onIdleSpanEnded(endTimestamp);\n      return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n    },\n  });\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   */\n  function _cancelIdleTimeout(): void {\n    if (_idleTimeoutID) {\n      clearTimeout(_idleTimeoutID);\n      _idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Cancels the existing child span timeout, if there is one.\n   */\n  function _cancelChildSpanTimeout(): void {\n    if (_childSpanTimeoutID) {\n      clearTimeout(_childSpanTimeoutID);\n      _childSpanTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  function _restartIdleTimeout(endTimestamp?: number): void {\n    _cancelIdleTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n        span.end(endTimestamp);\n      }\n    }, idleTimeout);\n  }\n\n  /**\n   * Restarts child span timeout, if there is none running it will start one.\n   */\n  function _restartChildSpanTimeout(endTimestamp?: number): void {\n    _cancelChildSpanTimeout();\n    _idleTimeoutID = setTimeout(() => {\n      if (!_finished && _autoFinishAllowed) {\n        _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n        span.end(endTimestamp);\n      }\n    }, childSpanTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  function _pushActivity(spanId: string): void {\n    _cancelIdleTimeout();\n    activities.set(spanId, true);\n\n    const endTimestamp = timestampInSeconds();\n    // We need to add the timeout here to have the real endtimestamp of the idle span\n    // Remember timestampInSeconds is in seconds, timeout is in ms\n    _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1000);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  function _popActivity(spanId: string): void {\n    if (activities.has(spanId)) {\n      activities.delete(spanId);\n    }\n\n    if (activities.size === 0) {\n      const endTimestamp = timestampInSeconds();\n      // We need to add the timeout here to have the real endtimestamp of the idle span\n      // Remember timestampInSeconds is in seconds, timeout is in ms\n      _restartIdleTimeout(endTimestamp + idleTimeout / 1000);\n      _cancelChildSpanTimeout();\n    }\n  }\n\n  function onIdleSpanEnded(endTimestamp: number): void {\n    _finished = true;\n    activities.clear();\n\n    _cleanupHooks.forEach(cleanup => cleanup());\n\n    _setSpanForScope(scope, previousActiveSpan);\n\n    const spanJSON = spanToJSON(span);\n\n    const { start_timestamp: startTimestamp } = spanJSON;\n    // This should never happen, but to make TS happy...\n    if (!startTimestamp) {\n      return;\n    }\n\n    const attributes = spanJSON.data;\n    if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n    }\n\n    debug.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n\n    const childSpans = getSpanDescendants(span).filter(child => child !== span);\n\n    let discardedSpans = 0;\n    childSpans.forEach(childSpan => {\n      // We cancel all pending spans with status \"cancelled\" to indicate the idle span was finished early\n      if (childSpan.isRecording()) {\n        childSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'cancelled' });\n        childSpan.end(endTimestamp);\n        DEBUG_BUILD &&\n          debug.log('[Tracing] Cancelling span since span ended early', JSON.stringify(childSpan, undefined, 2));\n      }\n\n      const childSpanJSON = spanToJSON(childSpan);\n      const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n\n      const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n\n      // Add a delta with idle timeout so that we prevent false positives\n      const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1000;\n      const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n\n      if (DEBUG_BUILD) {\n        const stringifiedSpan = JSON.stringify(childSpan, undefined, 2);\n        if (!spanStartedBeforeIdleSpanEnd) {\n          debug.log('[Tracing] Discarding span since it happened after idle span was finished', stringifiedSpan);\n        } else if (!spanEndedBeforeFinalTimeout) {\n          debug.log('[Tracing] Discarding span since it finished after idle span final timeout', stringifiedSpan);\n        }\n      }\n\n      if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n        removeChildSpanFromSpan(span, childSpan);\n        discardedSpans++;\n      }\n    });\n\n    if (discardedSpans > 0) {\n      span.setAttribute('sentry.idle_span_discarded_spans', discardedSpans);\n    }\n  }\n\n  _cleanupHooks.push(\n    client.on('spanStart', startedSpan => {\n      // If we already finished the idle span,\n      // or if this is the idle span itself being started,\n      // or if the started span has already been closed,\n      // we don't care about it for activity\n      if (\n        _finished ||\n        startedSpan === span ||\n        !!spanToJSON(startedSpan).timestamp ||\n        (startedSpan instanceof SentrySpan && startedSpan.isStandaloneSpan())\n      ) {\n        return;\n      }\n\n      const allSpans = getSpanDescendants(span);\n\n      // If the span that was just started is a child of the idle span, we should track it\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('spanEnd', endedSpan => {\n      if (_finished) {\n        return;\n      }\n\n      _popActivity(endedSpan.spanContext().spanId);\n    }),\n  );\n\n  _cleanupHooks.push(\n    client.on('idleSpanEnableAutoFinish', spanToAllowAutoFinish => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    }),\n  );\n\n  // We only start the initial idle timeout if we are not delaying the auto finish\n  if (!options.disableAutoFinish) {\n    _restartIdleTimeout();\n  }\n\n  setTimeout(() => {\n    if (!_finished) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n      span.end();\n    }\n  }, finalTimeout);\n\n  return span;\n}\n\nfunction _startIdleSpan(options: StartSpanOptions): Span {\n  const span = startInactiveSpan(options);\n\n  _setSpanForScope(getCurrentScope(), span);\n\n  DEBUG_BUILD && debug.log('[Tracing] Started span is an idle span');\n\n  return span;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}