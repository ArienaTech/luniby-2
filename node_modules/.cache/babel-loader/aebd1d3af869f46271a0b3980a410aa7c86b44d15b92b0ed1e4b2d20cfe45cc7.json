{"ast":null,"code":"import { getClient } from '../../currentScopes.js';\nimport { SPAN_STATUS_ERROR } from '../../tracing/spanstatus.js';\nimport { extractToolResultAttributes } from './attributeExtraction.js';\nimport { filterMcpPiiFromSpanData } from './piiFiltering.js';\n\n/**\n * Request-span correlation system for MCP server instrumentation\n *\n * Handles mapping requestId to span data for correlation with handler execution.\n * Uses WeakMap to scope correlation maps per transport instance, preventing\n * request ID collisions between different MCP sessions.\n */\n\n/**\n * Transport-scoped correlation system that prevents collisions between different MCP sessions\n * @internal Each transport instance gets its own correlation map, eliminating request ID conflicts\n */\nconst transportToSpanMap = new WeakMap();\n\n/**\n * Gets or creates the span map for a specific transport instance\n * @internal\n * @param transport - MCP transport instance\n * @returns Span map for the transport\n */\nfunction getOrCreateSpanMap(transport) {\n  let spanMap = transportToSpanMap.get(transport);\n  if (!spanMap) {\n    spanMap = new Map();\n    transportToSpanMap.set(transport, spanMap);\n  }\n  return spanMap;\n}\n\n/**\n * Stores span context for later correlation with handler execution\n * @param transport - MCP transport instance\n * @param requestId - Request identifier\n * @param span - Active span to correlate\n * @param method - MCP method name\n */\nfunction storeSpanForRequest(transport, requestId, span, method) {\n  const spanMap = getOrCreateSpanMap(transport);\n  spanMap.set(requestId, {\n    span,\n    method,\n    startTime: Date.now()\n  });\n}\n\n/**\n * Completes span with tool results and cleans up correlation\n * @param transport - MCP transport instance\n * @param requestId - Request identifier\n * @param result - Tool execution result for attribute extraction\n */\nfunction completeSpanWithResults(transport, requestId, result) {\n  const spanMap = getOrCreateSpanMap(transport);\n  const spanData = spanMap.get(requestId);\n  if (spanData) {\n    const {\n      span,\n      method\n    } = spanData;\n    if (method === 'tools/call') {\n      const rawToolAttributes = extractToolResultAttributes(result);\n      const client = getClient();\n      const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n      const toolAttributes = filterMcpPiiFromSpanData(rawToolAttributes, sendDefaultPii);\n      span.setAttributes(toolAttributes);\n    }\n    span.end();\n    spanMap.delete(requestId);\n  }\n}\n\n/**\n * Cleans up pending spans for a specific transport (when that transport closes)\n * @param transport - MCP transport instance\n * @returns Number of pending spans that were cleaned up\n */\nfunction cleanupPendingSpansForTransport(transport) {\n  const spanMap = transportToSpanMap.get(transport);\n  if (!spanMap) return 0;\n  const pendingCount = spanMap.size;\n  for (const [, spanData] of spanMap) {\n    spanData.span.setStatus({\n      code: SPAN_STATUS_ERROR,\n      message: 'cancelled'\n    });\n    spanData.span.end();\n  }\n  spanMap.clear();\n  return pendingCount;\n}\nexport { cleanupPendingSpansForTransport, completeSpanWithResults, storeSpanForRequest };","map":{"version":3,"names":["transportToSpanMap","WeakMap","getOrCreateSpanMap","transport","spanMap","get","Map","set","storeSpanForRequest","requestId","span","method","startTime","Date","now","completeSpanWithResults","result","spanData","rawToolAttributes","extractToolResultAttributes","client","getClient","sendDefaultPii","Boolean","getOptions","toolAttributes","filterMcpPiiFromSpanData","setAttributes","end","delete","cleanupPendingSpansForTransport","pendingCount","size","setStatus","code","SPAN_STATUS_ERROR","message","clear"],"sources":["/workspace/node_modules/@sentry/core/src/integrations/mcp-server/correlation.ts"],"sourcesContent":["/**\n * Request-span correlation system for MCP server instrumentation\n *\n * Handles mapping requestId to span data for correlation with handler execution.\n * Uses WeakMap to scope correlation maps per transport instance, preventing\n * request ID collisions between different MCP sessions.\n */\n\nimport { getClient } from '../../currentScopes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span } from '../../types-hoist/span';\nimport { extractToolResultAttributes } from './attributeExtraction';\nimport { filterMcpPiiFromSpanData } from './piiFiltering';\nimport type { MCPTransport, RequestId, RequestSpanMapValue } from './types';\n\n/**\n * Transport-scoped correlation system that prevents collisions between different MCP sessions\n * @internal Each transport instance gets its own correlation map, eliminating request ID conflicts\n */\nconst transportToSpanMap = new WeakMap<MCPTransport, Map<RequestId, RequestSpanMapValue>>();\n\n/**\n * Gets or creates the span map for a specific transport instance\n * @internal\n * @param transport - MCP transport instance\n * @returns Span map for the transport\n */\nfunction getOrCreateSpanMap(transport: MCPTransport): Map<RequestId, RequestSpanMapValue> {\n  let spanMap = transportToSpanMap.get(transport);\n  if (!spanMap) {\n    spanMap = new Map();\n    transportToSpanMap.set(transport, spanMap);\n  }\n  return spanMap;\n}\n\n/**\n * Stores span context for later correlation with handler execution\n * @param transport - MCP transport instance\n * @param requestId - Request identifier\n * @param span - Active span to correlate\n * @param method - MCP method name\n */\nexport function storeSpanForRequest(transport: MCPTransport, requestId: RequestId, span: Span, method: string): void {\n  const spanMap = getOrCreateSpanMap(transport);\n  spanMap.set(requestId, {\n    span,\n    method,\n    startTime: Date.now(),\n  });\n}\n\n/**\n * Completes span with tool results and cleans up correlation\n * @param transport - MCP transport instance\n * @param requestId - Request identifier\n * @param result - Tool execution result for attribute extraction\n */\nexport function completeSpanWithResults(transport: MCPTransport, requestId: RequestId, result: unknown): void {\n  const spanMap = getOrCreateSpanMap(transport);\n  const spanData = spanMap.get(requestId);\n  if (spanData) {\n    const { span, method } = spanData;\n\n    if (method === 'tools/call') {\n      const rawToolAttributes = extractToolResultAttributes(result);\n      const client = getClient();\n      const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n      const toolAttributes = filterMcpPiiFromSpanData(rawToolAttributes, sendDefaultPii);\n\n      span.setAttributes(toolAttributes);\n    }\n\n    span.end();\n    spanMap.delete(requestId);\n  }\n}\n\n/**\n * Cleans up pending spans for a specific transport (when that transport closes)\n * @param transport - MCP transport instance\n * @returns Number of pending spans that were cleaned up\n */\nexport function cleanupPendingSpansForTransport(transport: MCPTransport): number {\n  const spanMap = transportToSpanMap.get(transport);\n  if (!spanMap) return 0;\n\n  const pendingCount = spanMap.size;\n\n  for (const [, spanData] of spanMap) {\n    spanData.span.setStatus({\n      code: SPAN_STATUS_ERROR,\n      message: 'cancelled',\n    });\n    spanData.span.end();\n  }\n\n  spanMap.clear();\n  return pendingCount;\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA,MAAMA,kBAAA,GAAqB,IAAIC,OAAO,EAAqD;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,SAAS,EAAqD;EACxF,IAAIC,OAAA,GAAUJ,kBAAkB,CAACK,GAAG,CAACF,SAAS,CAAC;EAC/C,IAAI,CAACC,OAAO,EAAE;IACZA,OAAA,GAAU,IAAIE,GAAG,EAAE;IACnBN,kBAAkB,CAACO,GAAG,CAACJ,SAAS,EAAEC,OAAO,CAAC;EAC9C;EACE,OAAOA,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,mBAAmBA,CAACL,SAAS,EAAgBM,SAAS,EAAaC,IAAI,EAAQC,MAAM,EAAgB;EACnH,MAAMP,OAAA,GAAUF,kBAAkB,CAACC,SAAS,CAAC;EAC7CC,OAAO,CAACG,GAAG,CAACE,SAAS,EAAE;IACrBC,IAAI;IACJC,MAAM;IACNC,SAAS,EAAEC,IAAI,CAACC,GAAG;EACvB,CAAG,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,uBAAuBA,CAACZ,SAAS,EAAgBM,SAAS,EAAaO,MAAM,EAAiB;EAC5G,MAAMZ,OAAA,GAAUF,kBAAkB,CAACC,SAAS,CAAC;EAC7C,MAAMc,QAAA,GAAWb,OAAO,CAACC,GAAG,CAACI,SAAS,CAAC;EACvC,IAAIQ,QAAQ,EAAE;IACZ,MAAM;MAAEP,IAAI;MAAEC;IAAA,CAAO,GAAIM,QAAQ;IAEjC,IAAIN,MAAA,KAAW,YAAY,EAAE;MAC3B,MAAMO,iBAAA,GAAoBC,2BAA2B,CAACH,MAAM,CAAC;MAC7D,MAAMI,MAAA,GAASC,SAAS,EAAE;MAC1B,MAAMC,cAAA,GAAiBC,OAAO,CAACH,MAAM,EAAEI,UAAU,EAAE,CAACF,cAAc,CAAC;MACnE,MAAMG,cAAA,GAAiBC,wBAAwB,CAACR,iBAAiB,EAAEI,cAAc,CAAC;MAElFZ,IAAI,CAACiB,aAAa,CAACF,cAAc,CAAC;IACxC;IAEIf,IAAI,CAACkB,GAAG,EAAE;IACVxB,OAAO,CAACyB,MAAM,CAACpB,SAAS,CAAC;EAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASqB,+BAA+BA,CAAC3B,SAAS,EAAwB;EAC/E,MAAMC,OAAA,GAAUJ,kBAAkB,CAACK,GAAG,CAACF,SAAS,CAAC;EACjD,IAAI,CAACC,OAAO,EAAE,OAAO,CAAC;EAEtB,MAAM2B,YAAA,GAAe3B,OAAO,CAAC4B,IAAI;EAEjC,KAAK,MAAM,GAAGf,QAAQ,KAAKb,OAAO,EAAE;IAClCa,QAAQ,CAACP,IAAI,CAACuB,SAAS,CAAC;MACtBC,IAAI,EAAEC,iBAAiB;MACvBC,OAAO,EAAE;IACf,CAAK,CAAC;IACFnB,QAAQ,CAACP,IAAI,CAACkB,GAAG,EAAE;EACvB;EAEExB,OAAO,CAACiC,KAAK,EAAE;EACf,OAAON,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}