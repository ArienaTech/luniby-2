{"ast":null,"code":"import { getClient } from '../../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP } from '../../semanticAttributes.js';\nimport { startSpan } from '../../tracing/trace.js';\nimport { buildTypeSpecificAttributes, buildTransportAttributes } from './attributeExtraction.js';\nimport { MCP_SERVER_OP_VALUE, MCP_METHOD_NAME_ATTRIBUTE, MCP_ROUTE_SOURCE_VALUE, MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE, MCP_NOTIFICATION_ORIGIN_VALUE, MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE, MCP_FUNCTION_ORIGIN_VALUE } from './attributes.js';\nimport { extractTargetInfo } from './methodConfig.js';\nimport { filterMcpPiiFromSpanData } from './piiFiltering.js';\n\n/**\n * Span creation and management functions for MCP server instrumentation\n *\n * Provides unified span creation following OpenTelemetry MCP semantic conventions and our opinitionated take on MCP.\n * Handles both request and notification spans with attribute extraction.\n */\n\n/**\n * Creates a span name based on the method and target\n * @internal\n * @param method - MCP method name\n * @param target - Optional target identifier\n * @returns Formatted span name\n */\nfunction createSpanName(method, target) {\n  return target ? `${method} ${target}` : method;\n}\n\n/**\n * Build Sentry-specific attributes based on span type\n * @internal\n * @param type - Span type configuration\n * @returns Sentry-specific attributes\n */\nfunction buildSentryAttributes(type) {\n  let op;\n  let origin;\n  switch (type) {\n    case 'request':\n      op = MCP_SERVER_OP_VALUE;\n      origin = MCP_FUNCTION_ORIGIN_VALUE;\n      break;\n    case 'notification-incoming':\n      op = MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE;\n      origin = MCP_NOTIFICATION_ORIGIN_VALUE;\n      break;\n    case 'notification-outgoing':\n      op = MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE;\n      origin = MCP_NOTIFICATION_ORIGIN_VALUE;\n      break;\n  }\n  return {\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: MCP_ROUTE_SOURCE_VALUE\n  };\n}\n\n/**\n * Unified builder for creating MCP spans\n * @internal\n * @param config - Span configuration\n * @returns Created span\n */\nfunction createMcpSpan(config) {\n  const {\n    type,\n    message,\n    transport,\n    extra,\n    callback\n  } = config;\n  const {\n    method\n  } = message;\n  const params = message.params;\n\n  // Determine span name based on type and OTEL conventions\n  let spanName;\n  if (type === 'request') {\n    const targetInfo = extractTargetInfo(method, params || {});\n    spanName = createSpanName(method, targetInfo.target);\n  } else {\n    // For notifications, use method name directly per OpenTelemetry conventions\n    spanName = method;\n  }\n  const rawAttributes = {\n    ...buildTransportAttributes(transport, extra),\n    [MCP_METHOD_NAME_ATTRIBUTE]: method,\n    ...buildTypeSpecificAttributes(type, message, params),\n    ...buildSentryAttributes(type)\n  };\n  const client = getClient();\n  const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n  const attributes = filterMcpPiiFromSpanData(rawAttributes, sendDefaultPii);\n  return startSpan({\n    name: spanName,\n    forceTransaction: true,\n    attributes\n  }, callback);\n}\n\n/**\n * Creates a span for incoming MCP notifications\n * @param jsonRpcMessage - Notification message\n * @param transport - MCP transport instance\n * @param extra - Extra handler data\n * @param callback - Span execution callback\n * @returns Span execution result\n */\nfunction createMcpNotificationSpan(jsonRpcMessage, transport, extra, callback) {\n  return createMcpSpan({\n    type: 'notification-incoming',\n    message: jsonRpcMessage,\n    transport,\n    extra,\n    callback\n  });\n}\n\n/**\n * Creates a span for outgoing MCP notifications\n * @param jsonRpcMessage - Notification message\n * @param transport - MCP transport instance\n * @param callback - Span execution callback\n * @returns Span execution result\n */\nfunction createMcpOutgoingNotificationSpan(jsonRpcMessage, transport, callback) {\n  return createMcpSpan({\n    type: 'notification-outgoing',\n    message: jsonRpcMessage,\n    transport,\n    callback\n  });\n}\n\n/**\n * Builds span configuration for MCP server requests\n * @param jsonRpcMessage - Request message\n * @param transport - MCP transport instance\n * @param extra - Optional extra handler data\n * @returns Span configuration object\n */\nfunction buildMcpServerSpanConfig(jsonRpcMessage, transport, extra) {\n  const {\n    method\n  } = jsonRpcMessage;\n  const params = jsonRpcMessage.params;\n  const targetInfo = extractTargetInfo(method, params || {});\n  const spanName = createSpanName(method, targetInfo.target);\n  const rawAttributes = {\n    ...buildTransportAttributes(transport, extra),\n    [MCP_METHOD_NAME_ATTRIBUTE]: method,\n    ...buildTypeSpecificAttributes('request', jsonRpcMessage, params),\n    ...buildSentryAttributes('request')\n  };\n  const client = getClient();\n  const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n  const attributes = filterMcpPiiFromSpanData(rawAttributes, sendDefaultPii);\n  return {\n    name: spanName,\n    op: MCP_SERVER_OP_VALUE,\n    forceTransaction: true,\n    attributes\n  };\n}\nexport { buildMcpServerSpanConfig, createMcpNotificationSpan, createMcpOutgoingNotificationSpan };","map":{"version":3,"names":["createSpanName","method","target","buildSentryAttributes","type","op","origin","MCP_SERVER_OP_VALUE","MCP_FUNCTION_ORIGIN_VALUE","MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE","MCP_NOTIFICATION_ORIGIN_VALUE","MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","MCP_ROUTE_SOURCE_VALUE","createMcpSpan","config","message","transport","extra","callback","params","spanName","targetInfo","extractTargetInfo","rawAttributes","buildTransportAttributes","MCP_METHOD_NAME_ATTRIBUTE","buildTypeSpecificAttributes","client","getClient","sendDefaultPii","Boolean","getOptions","attributes","filterMcpPiiFromSpanData","startSpan","name","forceTransaction","createMcpNotificationSpan","jsonRpcMessage","createMcpOutgoingNotificationSpan","buildMcpServerSpanConfig"],"sources":["/workspace/node_modules/@sentry/core/src/integrations/mcp-server/spans.ts"],"sourcesContent":["/**\n * Span creation and management functions for MCP server instrumentation\n *\n * Provides unified span creation following OpenTelemetry MCP semantic conventions and our opinitionated take on MCP.\n * Handles both request and notification spans with attribute extraction.\n */\n\nimport { getClient } from '../../currentScopes';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '../../semanticAttributes';\nimport { startSpan } from '../../tracing';\nimport { buildTransportAttributes, buildTypeSpecificAttributes } from './attributeExtraction';\nimport {\n  MCP_FUNCTION_ORIGIN_VALUE,\n  MCP_METHOD_NAME_ATTRIBUTE,\n  MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE,\n  MCP_NOTIFICATION_ORIGIN_VALUE,\n  MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE,\n  MCP_ROUTE_SOURCE_VALUE,\n  MCP_SERVER_OP_VALUE,\n} from './attributes';\nimport { extractTargetInfo } from './methodConfig';\nimport { filterMcpPiiFromSpanData } from './piiFiltering';\nimport type { ExtraHandlerData, JsonRpcNotification, JsonRpcRequest, McpSpanConfig, MCPTransport } from './types';\n\n/**\n * Creates a span name based on the method and target\n * @internal\n * @param method - MCP method name\n * @param target - Optional target identifier\n * @returns Formatted span name\n */\nfunction createSpanName(method: string, target?: string): string {\n  return target ? `${method} ${target}` : method;\n}\n\n/**\n * Build Sentry-specific attributes based on span type\n * @internal\n * @param type - Span type configuration\n * @returns Sentry-specific attributes\n */\nfunction buildSentryAttributes(type: McpSpanConfig['type']): Record<string, string> {\n  let op: string;\n  let origin: string;\n\n  switch (type) {\n    case 'request':\n      op = MCP_SERVER_OP_VALUE;\n      origin = MCP_FUNCTION_ORIGIN_VALUE;\n      break;\n    case 'notification-incoming':\n      op = MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE;\n      origin = MCP_NOTIFICATION_ORIGIN_VALUE;\n      break;\n    case 'notification-outgoing':\n      op = MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE;\n      origin = MCP_NOTIFICATION_ORIGIN_VALUE;\n      break;\n  }\n\n  return {\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: MCP_ROUTE_SOURCE_VALUE,\n  };\n}\n\n/**\n * Unified builder for creating MCP spans\n * @internal\n * @param config - Span configuration\n * @returns Created span\n */\nfunction createMcpSpan(config: McpSpanConfig): unknown {\n  const { type, message, transport, extra, callback } = config;\n  const { method } = message;\n  const params = message.params as Record<string, unknown> | undefined;\n\n  // Determine span name based on type and OTEL conventions\n  let spanName: string;\n  if (type === 'request') {\n    const targetInfo = extractTargetInfo(method, params || {});\n    spanName = createSpanName(method, targetInfo.target);\n  } else {\n    // For notifications, use method name directly per OpenTelemetry conventions\n    spanName = method;\n  }\n\n  const rawAttributes: Record<string, string | number> = {\n    ...buildTransportAttributes(transport, extra),\n    [MCP_METHOD_NAME_ATTRIBUTE]: method,\n    ...buildTypeSpecificAttributes(type, message, params),\n    ...buildSentryAttributes(type),\n  };\n\n  const client = getClient();\n  const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n  const attributes = filterMcpPiiFromSpanData(rawAttributes, sendDefaultPii) as Record<string, string | number>;\n\n  return startSpan(\n    {\n      name: spanName,\n      forceTransaction: true,\n      attributes,\n    },\n    callback,\n  );\n}\n\n/**\n * Creates a span for incoming MCP notifications\n * @param jsonRpcMessage - Notification message\n * @param transport - MCP transport instance\n * @param extra - Extra handler data\n * @param callback - Span execution callback\n * @returns Span execution result\n */\nexport function createMcpNotificationSpan(\n  jsonRpcMessage: JsonRpcNotification,\n  transport: MCPTransport,\n  extra: ExtraHandlerData,\n  callback: () => unknown,\n): unknown {\n  return createMcpSpan({\n    type: 'notification-incoming',\n    message: jsonRpcMessage,\n    transport,\n    extra,\n    callback,\n  });\n}\n\n/**\n * Creates a span for outgoing MCP notifications\n * @param jsonRpcMessage - Notification message\n * @param transport - MCP transport instance\n * @param callback - Span execution callback\n * @returns Span execution result\n */\nexport function createMcpOutgoingNotificationSpan(\n  jsonRpcMessage: JsonRpcNotification,\n  transport: MCPTransport,\n  callback: () => unknown,\n): unknown {\n  return createMcpSpan({\n    type: 'notification-outgoing',\n    message: jsonRpcMessage,\n    transport,\n    callback,\n  });\n}\n\n/**\n * Builds span configuration for MCP server requests\n * @param jsonRpcMessage - Request message\n * @param transport - MCP transport instance\n * @param extra - Optional extra handler data\n * @returns Span configuration object\n */\nexport function buildMcpServerSpanConfig(\n  jsonRpcMessage: JsonRpcRequest,\n  transport: MCPTransport,\n  extra?: ExtraHandlerData,\n): {\n  name: string;\n  op: string;\n  forceTransaction: boolean;\n  attributes: Record<string, string | number>;\n} {\n  const { method } = jsonRpcMessage;\n  const params = jsonRpcMessage.params as Record<string, unknown> | undefined;\n\n  const targetInfo = extractTargetInfo(method, params || {});\n  const spanName = createSpanName(method, targetInfo.target);\n\n  const rawAttributes: Record<string, string | number> = {\n    ...buildTransportAttributes(transport, extra),\n    [MCP_METHOD_NAME_ATTRIBUTE]: method,\n    ...buildTypeSpecificAttributes('request', jsonRpcMessage, params),\n    ...buildSentryAttributes('request'),\n  };\n\n  const client = getClient();\n  const sendDefaultPii = Boolean(client?.getOptions().sendDefaultPii);\n  const attributes = filterMcpPiiFromSpanData(rawAttributes, sendDefaultPii) as Record<string, string | number>;\n\n  return {\n    name: spanName,\n    op: MCP_SERVER_OP_VALUE,\n    forceTransaction: true,\n    attributes,\n  };\n}\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAcA,CAACC,MAAM,EAAUC,MAAM,EAAmB;EAC/D,OAAOA,MAAA,GAAS,GAACD,MAAA,IAAAC,MAAA,KAAAD,MAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAE,sBAAAC,IAAA;EACA,IAAAC,EAAA;EACA,IAAAC,MAAA;EAEA,QAAAF,IAAA;IACA;MACAC,EAAA,GAAAE,mBAAA;MACAD,MAAA,GAAAE,yBAAA;MACA;IACA;MACAH,EAAA,GAAAI,0CAAA;MACAH,MAAA,GAAAI,6BAAA;MACA;IACA;MACAL,EAAA,GAAAM,0CAAA;MACAL,MAAA,GAAAI,6BAAA;MACA;EACA;EAEA;IACA,CAAAE,4BAAA,GAAAP,EAAA;IACA,CAAAQ,gCAAA,GAAAP,MAAA;IACA,CAAAQ,gCAAA,GAAAC;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAC,cAAAC,MAAA;EACA;IAAAb,IAAA;IAAAc,OAAA;IAAAC,SAAA;IAAAC,KAAA;IAAAC;EAAA,IAAAJ,MAAA;EACA;IAAAhB;EAAA,IAAAiB,OAAA;EACA,MAAAI,MAAA,GAAAJ,OAAA,CAAAI,MAAA;;EAEA;EACA,IAAAC,QAAA;EACA,IAAAnB,IAAA;IACA,MAAAoB,UAAA,GAAAC,iBAAA,CAAAxB,MAAA,EAAAqB,MAAA;IACAC,QAAA,GAAAvB,cAAA,CAAAC,MAAA,EAAAuB,UAAA,CAAAtB,MAAA;EACA;IACA;IACAqB,QAAA,GAAAtB,MAAA;EACA;EAEA,MAAAyB,aAAA;IACA,GAAAC,wBAAA,CAAAR,SAAA,EAAAC,KAAA;IACA,CAAAQ,yBAAA,GAAA3B,MAAA;IACA,GAAA4B,2BAAA,CAAAzB,IAAA,EAAAc,OAAA,EAAAI,MAAA;IACA,GAAAnB,qBAAA,CAAAC,IAAA;EACA;EAEA,MAAA0B,MAAA,GAAAC,SAAA;EACA,MAAAC,cAAA,GAAAC,OAAA,CAAAH,MAAA,EAAAI,UAAA,GAAAF,cAAA;EACA,MAAAG,UAAA,GAAAC,wBAAA,CAAAV,aAAA,EAAAM,cAAA;EAEA,OAAAK,SAAA,CACA;IACAC,IAAA,EAAAf,QAAA;IACAgB,gBAAA;IACAJ;EACA,GACAd,QACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAmB,0BACAC,cAAA,EACAtB,SAAA,EACAC,KAAA,EACAC,QAAA,EACA;EACA,OAAAL,aAAA;IACAZ,IAAA;IACAc,OAAA,EAAAuB,cAAA;IACAtB,SAAA;IACAC,KAAA;IACAC;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAqB,kCACAD,cAAA,EACAtB,SAAA,EACAE,QAAA,EACA;EACA,OAAAL,aAAA;IACAZ,IAAA;IACAc,OAAA,EAAAuB,cAAA;IACAtB,SAAA;IACAE;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAsB,yBACAF,cAAA,EACAtB,SAAA,EACAC,KAAA,EAMA;EACA;IAAAnB;EAAA,IAAAwC,cAAA;EACA,MAAAnB,MAAA,GAAAmB,cAAA,CAAAnB,MAAA;EAEA,MAAAE,UAAA,GAAAC,iBAAA,CAAAxB,MAAA,EAAAqB,MAAA;EACA,MAAAC,QAAA,GAAAvB,cAAA,CAAAC,MAAA,EAAAuB,UAAA,CAAAtB,MAAA;EAEA,MAAAwB,aAAA;IACA,GAAAC,wBAAA,CAAAR,SAAA,EAAAC,KAAA;IACA,CAAAQ,yBAAA,GAAA3B,MAAA;IACA,GAAA4B,2BAAA,YAAAY,cAAA,EAAAnB,MAAA;IACA,GAAAnB,qBAAA;EACA;EAEA,MAAA2B,MAAA,GAAAC,SAAA;EACA,MAAAC,cAAA,GAAAC,OAAA,CAAAH,MAAA,EAAAI,UAAA,GAAAF,cAAA;EACA,MAAAG,UAAA,GAAAC,wBAAA,CAAAV,aAAA,EAAAM,cAAA;EAEA;IACAM,IAAA,EAAAf,QAAA;IACAlB,EAAA,EAAAE,mBAAA;IACAgC,gBAAA;IACAJ;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}