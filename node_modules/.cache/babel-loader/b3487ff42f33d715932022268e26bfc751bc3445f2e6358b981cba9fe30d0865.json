{"ast":null,"code":"import { defineIntegration, _INTERNAL_copyFlagsFromScopeToEvent, fill, _INTERNAL_insertFlagToScope, _INTERNAL_addFeatureFlagToActiveSpan, debug } from '@sentry/core';\nimport { DEBUG_BUILD } from '../../../debug-build.js';\n\n/**\n * Sentry integration for capturing feature flag evaluations from the Unleash SDK.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import { UnleashClient } from 'unleash-proxy-client';\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   dsn: '___PUBLIC_DSN___',\n *   integrations: [Sentry.unleashIntegration({featureFlagClientClass: UnleashClient})],\n * });\n *\n * const unleash = new UnleashClient(...);\n * unleash.start();\n *\n * unleash.isEnabled('my-feature');\n * Sentry.captureException(new Error('something went wrong'));\n * ```\n */\nconst unleashIntegration = defineIntegration(_ref => {\n  let {\n    featureFlagClientClass: unleashClientClass\n  } = _ref;\n  return {\n    name: 'Unleash',\n    setupOnce() {\n      const unleashClientPrototype = unleashClientClass.prototype;\n      fill(unleashClientPrototype, 'isEnabled', _wrappedIsEnabled);\n    },\n    processEvent(event, _hint, _client) {\n      return _INTERNAL_copyFlagsFromScopeToEvent(event);\n    }\n  };\n});\n\n/**\n * Wraps the UnleashClient.isEnabled method to capture feature flag evaluations. Its only side effect is writing to Sentry scope.\n *\n * This wrapper is safe for all isEnabled signatures. If the signature does not match (this: UnleashClient, toggleName: string, ...args: unknown[]) => boolean,\n * we log an error and return the original result.\n *\n * @param original - The original method.\n * @returns Wrapped method. Results should match the original.\n */\nfunction _wrappedIsEnabled(original) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const toggleName = args[0];\n    const result = original.apply(this, args);\n    if (typeof toggleName === 'string' && typeof result === 'boolean') {\n      _INTERNAL_insertFlagToScope(toggleName, result);\n      _INTERNAL_addFeatureFlagToActiveSpan(toggleName, result);\n    } else if (DEBUG_BUILD) {\n      debug.error(`[Feature Flags] UnleashClient.isEnabled does not match expected signature. arg0: ${toggleName} (${typeof toggleName}), result: ${result} (${typeof result})`);\n    }\n    return result;\n  };\n}\nexport { unleashIntegration };","map":{"version":3,"names":["unleashIntegration","defineIntegration","_ref","featureFlagClientClass","unleashClientClass","name","setupOnce","unleashClientPrototype","prototype","fill","_wrappedIsEnabled","processEvent","event","_hint","_client","_INTERNAL_copyFlagsFromScopeToEvent","original","_len","arguments","length","args","Array","_key","toggleName","result","apply","_INTERNAL_insertFlagToScope","_INTERNAL_addFeatureFlagToActiveSpan","DEBUG_BUILD","debug","error"],"sources":["/workspace/node_modules/@sentry/browser/src/integrations/featureFlags/unleash/integration.ts"],"sourcesContent":["import type { Client, Event, EventHint, IntegrationFn } from '@sentry/core';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n  debug,\n  defineIntegration,\n  fill,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../../../debug-build';\nimport type { UnleashClient, UnleashClientClass } from './types';\n\ntype UnleashIntegrationOptions = {\n  featureFlagClientClass: UnleashClientClass;\n};\n\n/**\n * Sentry integration for capturing feature flag evaluations from the Unleash SDK.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import { UnleashClient } from 'unleash-proxy-client';\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   dsn: '___PUBLIC_DSN___',\n *   integrations: [Sentry.unleashIntegration({featureFlagClientClass: UnleashClient})],\n * });\n *\n * const unleash = new UnleashClient(...);\n * unleash.start();\n *\n * unleash.isEnabled('my-feature');\n * Sentry.captureException(new Error('something went wrong'));\n * ```\n */\nexport const unleashIntegration = defineIntegration(\n  ({ featureFlagClientClass: unleashClientClass }: UnleashIntegrationOptions) => {\n    return {\n      name: 'Unleash',\n\n      setupOnce() {\n        const unleashClientPrototype = unleashClientClass.prototype as UnleashClient;\n        fill(unleashClientPrototype, 'isEnabled', _wrappedIsEnabled);\n      },\n\n      processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n        return _INTERNAL_copyFlagsFromScopeToEvent(event);\n      },\n    };\n  },\n) satisfies IntegrationFn;\n\n/**\n * Wraps the UnleashClient.isEnabled method to capture feature flag evaluations. Its only side effect is writing to Sentry scope.\n *\n * This wrapper is safe for all isEnabled signatures. If the signature does not match (this: UnleashClient, toggleName: string, ...args: unknown[]) => boolean,\n * we log an error and return the original result.\n *\n * @param original - The original method.\n * @returns Wrapped method. Results should match the original.\n */\nfunction _wrappedIsEnabled(\n  original: (this: UnleashClient, ...args: unknown[]) => unknown,\n): (this: UnleashClient, ...args: unknown[]) => unknown {\n  return function (this: UnleashClient, ...args: unknown[]): unknown {\n    const toggleName = args[0];\n    const result = original.apply(this, args);\n\n    if (typeof toggleName === 'string' && typeof result === 'boolean') {\n      _INTERNAL_insertFlagToScope(toggleName, result);\n      _INTERNAL_addFeatureFlagToActiveSpan(toggleName, result);\n    } else if (DEBUG_BUILD) {\n      debug.error(\n        `[Feature Flags] UnleashClient.isEnabled does not match expected signature. arg0: ${toggleName} (${typeof toggleName}), result: ${result} (${typeof result})`,\n      );\n    }\n    return result;\n  };\n}\n"],"mappings":";;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,kBAAA,GAAqBC,iBAAiB,CACjDC,IAAA,IAA+E;EAAA,IAA9E;IAAEC,sBAAsB,EAAEC;EAAA,CAAoB,GAAAF,IAAA;EAC7C,OAAO;IACLG,IAAI,EAAE,SAAS;IAEfC,SAASA,CAAA,EAAG;MACV,MAAMC,sBAAA,GAAyBH,kBAAkB,CAACI,SAAA;MAClDC,IAAI,CAACF,sBAAsB,EAAE,WAAW,EAAEG,iBAAiB,CAAC;IACpE,CAAO;IAEDC,YAAYA,CAACC,KAAK,EAASC,KAAK,EAAaC,OAAO,EAAiB;MACnE,OAAOC,mCAAmC,CAACH,KAAK,CAAC;IACzD;EACA,CAAK;AACL,CACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,iBAAiBA,CACxBM,QAAQ,EAC8C;EACtD,OAAO,YAA4D;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAA1BC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IAC3C,MAAMC,UAAA,GAAaH,IAAI,CAAC,CAAC,CAAC;IAC1B,MAAMI,MAAA,GAASR,QAAQ,CAACS,KAAK,CAAC,IAAI,EAAEL,IAAI,CAAC;IAEzC,IAAI,OAAOG,UAAA,KAAe,YAAY,OAAOC,MAAA,KAAW,SAAS,EAAE;MACjEE,2BAA2B,CAACH,UAAU,EAAEC,MAAM,CAAC;MAC/CG,oCAAoC,CAACJ,UAAU,EAAEC,MAAM,CAAC;IAC9D,CAAI,MAAO,IAAII,WAAW,EAAE;MACtBC,KAAK,CAACC,KAAK,CACT,oFAAoFP,UAAU,KAAK,OAAOA,UAAU,cAAcC,MAAM,KAAK,OAAOA,MAAM,GAClK,CAAO;IACP;IACI,OAAOA,MAAM;EACjB,CAAG;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}