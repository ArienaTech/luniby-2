{"ast":null,"code":"import { flush } from '../exports.js';\nimport { debug } from './debug-logger.js';\nimport { vercelWaitUntil } from './vercelWaitUntil.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\nasync function flushWithTimeout(timeout) {\n  try {\n    debug.log('Flushing events...');\n    await flush(timeout);\n    debug.log('Done flushing events');\n  } catch (e) {\n    debug.log('Error while flushing events:\\n', e);\n  }\n}\n\n/**\n *  Flushes the event queue with a timeout in serverless environments to ensure that events are sent to Sentry before the\n *  serverless function execution ends.\n *\n * The function is async, but in environments that support a `waitUntil` mechanism, it will run synchronously.\n *\n * This function is aware of the following serverless platforms:\n * - Cloudflare: If a Cloudflare context is provided, it will use `ctx.waitUntil()` to flush events (keeps the `this` context of `ctx`).\n *               If a `cloudflareWaitUntil` function is provided, it will use that to flush events (looses the `this` context of `ctx`).\n * - Vercel: It detects the Vercel environment and uses Vercel's `waitUntil` function.\n * - Other Serverless (AWS Lambda, Google Cloud, etc.): It detects the environment via environment variables\n *   and uses a regular `await flush()`.\n *\n *  @internal This function is supposed for internal Sentry SDK usage only.\n *  @hidden\n */\nasync function flushIfServerless() {\n  let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    timeout = 2000\n  } = params;\n  if ('cloudflareWaitUntil' in params && typeof params?.cloudflareWaitUntil === 'function') {\n    params.cloudflareWaitUntil(flushWithTimeout(timeout));\n    return;\n  }\n  if ('cloudflareCtx' in params && typeof params.cloudflareCtx?.waitUntil === 'function') {\n    params.cloudflareCtx.waitUntil(flushWithTimeout(timeout));\n    return;\n  }\n\n  // @ts-expect-error This is not typed\n  if (GLOBAL_OBJ[Symbol.for('@vercel/request-context')]) {\n    // Vercel has a waitUntil equivalent that works without execution context\n    vercelWaitUntil(flushWithTimeout(timeout));\n    return;\n  }\n  if (typeof process === 'undefined') {\n    return;\n  }\n  const isServerless = !!process.env.FUNCTIONS_WORKER_RUNTIME ||\n  // Azure Functions\n  !!process.env.LAMBDA_TASK_ROOT ||\n  // AWS Lambda\n  !!process.env.K_SERVICE ||\n  // Google Cloud Run\n  !!process.env.CF_PAGES ||\n  // Cloudflare Pages\n  !!process.env.VERCEL || !!process.env.NETLIFY;\n  if (isServerless) {\n    // Use regular flush for environments without a generic waitUntil mechanism\n    await flushWithTimeout(timeout);\n  }\n}\nexport { flushIfServerless };","map":{"version":3,"names":["flushWithTimeout","timeout","debug","log","flush","e","flushIfServerless","params","arguments","length","undefined","cloudflareWaitUntil","cloudflareCtx","waitUntil","GLOBAL_OBJ","Symbol","for","vercelWaitUntil","process","isServerless","env","FUNCTIONS_WORKER_RUNTIME","LAMBDA_TASK_ROOT","K_SERVICE","CF_PAGES","VERCEL","NETLIFY"],"sources":["/workspace/node_modules/@sentry/core/src/utils/flushIfServerless.ts"],"sourcesContent":["import { flush } from '../exports';\nimport { debug } from './debug-logger';\nimport { vercelWaitUntil } from './vercelWaitUntil';\nimport { GLOBAL_OBJ } from './worldwide';\n\ntype MinimalCloudflareContext = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  waitUntil(promise: Promise<any>): void;\n};\n\nasync function flushWithTimeout(timeout: number): Promise<void> {\n  try {\n    debug.log('Flushing events...');\n    await flush(timeout);\n    debug.log('Done flushing events');\n  } catch (e) {\n    debug.log('Error while flushing events:\\n', e);\n  }\n}\n\n/**\n *  Flushes the event queue with a timeout in serverless environments to ensure that events are sent to Sentry before the\n *  serverless function execution ends.\n *\n * The function is async, but in environments that support a `waitUntil` mechanism, it will run synchronously.\n *\n * This function is aware of the following serverless platforms:\n * - Cloudflare: If a Cloudflare context is provided, it will use `ctx.waitUntil()` to flush events (keeps the `this` context of `ctx`).\n *               If a `cloudflareWaitUntil` function is provided, it will use that to flush events (looses the `this` context of `ctx`).\n * - Vercel: It detects the Vercel environment and uses Vercel's `waitUntil` function.\n * - Other Serverless (AWS Lambda, Google Cloud, etc.): It detects the environment via environment variables\n *   and uses a regular `await flush()`.\n *\n *  @internal This function is supposed for internal Sentry SDK usage only.\n *  @hidden\n */\nexport async function flushIfServerless(\n  params: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | { timeout?: number; cloudflareWaitUntil?: (task: Promise<any>) => void }\n    | { timeout?: number; cloudflareCtx?: MinimalCloudflareContext } = {},\n): Promise<void> {\n  const { timeout = 2000 } = params;\n\n  if ('cloudflareWaitUntil' in params && typeof params?.cloudflareWaitUntil === 'function') {\n    params.cloudflareWaitUntil(flushWithTimeout(timeout));\n    return;\n  }\n\n  if ('cloudflareCtx' in params && typeof params.cloudflareCtx?.waitUntil === 'function') {\n    params.cloudflareCtx.waitUntil(flushWithTimeout(timeout));\n    return;\n  }\n\n  // @ts-expect-error This is not typed\n  if (GLOBAL_OBJ[Symbol.for('@vercel/request-context')]) {\n    // Vercel has a waitUntil equivalent that works without execution context\n    vercelWaitUntil(flushWithTimeout(timeout));\n    return;\n  }\n\n  if (typeof process === 'undefined') {\n    return;\n  }\n\n  const isServerless =\n    !!process.env.FUNCTIONS_WORKER_RUNTIME || // Azure Functions\n    !!process.env.LAMBDA_TASK_ROOT || // AWS Lambda\n    !!process.env.K_SERVICE || // Google Cloud Run\n    !!process.env.CF_PAGES || // Cloudflare Pages\n    !!process.env.VERCEL ||\n    !!process.env.NETLIFY;\n\n  if (isServerless) {\n    // Use regular flush for environments without a generic waitUntil mechanism\n    await flushWithTimeout(timeout);\n  }\n}\n"],"mappings":";;;;AAUA,eAAeA,gBAAgBA,CAACC,OAAO,EAAyB;EAC9D,IAAI;IACFC,KAAK,CAACC,GAAG,CAAC,oBAAoB,CAAC;IAC/B,MAAMC,KAAK,CAACH,OAAO,CAAC;IACpBC,KAAK,CAACC,GAAG,CAAC,sBAAsB,CAAC;EACrC,CAAE,CAAE,OAAOE,CAAC,EAAE;IACVH,KAAK,CAACC,GAAG,CAAC,gCAAgC,EAAEE,CAAC,CAAC;EAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeC,iBAAiBA,CAAA,EAItB;EAAA,IAHfC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAEqE,EAAE;EAEvE,MAAM;IAAEP,OAAA,GAAU;EAAA,CAAK,GAAIM,MAAM;EAEjC,IAAI,yBAAyBA,MAAA,IAAU,OAAOA,MAAM,EAAEI,mBAAA,KAAwB,UAAU,EAAE;IACxFJ,MAAM,CAACI,mBAAmB,CAACX,gBAAgB,CAACC,OAAO,CAAC,CAAC;IACrD;EACJ;EAEE,IAAI,mBAAmBM,MAAA,IAAU,OAAOA,MAAM,CAACK,aAAa,EAAEC,SAAA,KAAc,UAAU,EAAE;IACtFN,MAAM,CAACK,aAAa,CAACC,SAAS,CAACb,gBAAgB,CAACC,OAAO,CAAC,CAAC;IACzD;EACJ;;EAEA;EACE,IAAIa,UAAU,CAACC,MAAM,CAACC,GAAG,CAAC,yBAAyB,CAAC,CAAC,EAAE;IACzD;IACIC,eAAe,CAACjB,gBAAgB,CAACC,OAAO,CAAC,CAAC;IAC1C;EACJ;EAEE,IAAI,OAAOiB,OAAA,KAAY,WAAW,EAAE;IAClC;EACJ;EAEE,MAAMC,YAAA,GACJ,CAAC,CAACD,OAAO,CAACE,GAAG,CAACC,wBAAA;EAAA;EACd,CAAC,CAACH,OAAO,CAACE,GAAG,CAACE,gBAAA;EAAA;EACd,CAAC,CAACJ,OAAO,CAACE,GAAG,CAACG,SAAA;EAAA;EACd,CAAC,CAACL,OAAO,CAACE,GAAG,CAACI,QAAA;EAAA;EACd,CAAC,CAACN,OAAO,CAACE,GAAG,CAACK,MAAA,IACd,CAAC,CAACP,OAAO,CAACE,GAAG,CAACM,OAAO;EAEvB,IAAIP,YAAY,EAAE;IACpB;IACI,MAAMnB,gBAAgB,CAACC,OAAO,CAAC;EACnC;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}